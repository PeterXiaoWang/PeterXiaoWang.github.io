<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CaseStudy-AsyncTask执行问题小结</title>
    <url>/2019/08/23/CaseStudy-AsyncTask%E6%89%A7%E8%A1%8C%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>APP启动优化</title>
    <url>/2023/08/23/APP%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1>启动优化总结</h1>
<h1>不同的启动方式</h1>
<ul>
<li>热启动：在 Activity 的实例与 Application 的实例未被系统销毁的情况下进行启动，可以减少启动所需要执行的生命周期流程，这种启动被称为热启动。</li>
<li>冷启动：需要执行所有生命周期流程的启动被称为冷启动。</li>
<li>温启动：即使 Activity 被系统回收，应用的实例仍然可能保留。这种情况下，只需要重新完成 Activity 的生命周期即可。这种启动方式介于冷启动和热启动之间，因此被称为“温启动”。</li>
</ul>
<p><img src="/2023/08/23/APP启动优化/%E5%90%AF%E5%8A%A8%E5%88%86%E7%B1%BB.png" alt="启动分类.png"></p>
<p>在用户视角来看，启动是必经过程，而且启动的时候用户只能等待启动完成，因此启动时间的缩短能否有效提高用户的使用体验。</p>
<h1>优化方法</h1>
<h2 id="启动框架">启动框架</h2>
<p>整体思路：将启动任务管理起来，同时给业务按需提供初始化时机。通过启动框架，可以实现更好地调度启动任务，管理启动任务。以下是一个启动框架的大体架构图。</p>
<p><img src="/2023/08/23/APP启动优化/%E5%90%AF%E5%8A%A8%E6%A1%86%E6%9E%B6.png" alt="启动框架.png"></p>
<p>另外，我们也可以根据业务场景的不同来决定执行不同的启动任务，例如外链唤起APP的场景下，首页相关的启动任务就可以不用执行了，这样可以加快外链的打开速度。</p>
<h2 id="代码优化">代码优化</h2>
<p>这里总结一些启动优化过程中的一些代码优化方法，包括锁竞争、IO 治理、CPU 优化、IPC 优化等。</p>
<h3 id="锁竞争">锁竞争</h3>
<p>启动优化过程中，经常会遇到主线程和子线程存在锁竞争导致耗时增长的问题，通过 systrace 工具（或者升级版 perfetto 工具）可以很容易发现启动过程中的锁竞争问题。</p>
<h3 id="io治理">IO治理</h3>
<p>启动过程中的 IO 操作会影响启动时间，特别是对于低端机，同样的 I/O 操作耗时可能是高端机器的几十倍。</p>
<p>分析过程中可以使用 Simpleperf 工具（Simpleperf 是一个通用的命令行 CPU 性能剖析工具，包含在面向 Mac、Linux 和 Windows 的 NDK 中。）</p>
<p>统计启动过程中的 IO 操作，可以开发工具，其原理是通过 native hook 文件操作的 open、read、write、close等函数来统计IO数据，得到启动过程中的 IO 数据后，我们可以从 IO 次数，read、write耗时、主线程 IO 等角度进行分析优化。</p>
<h3 id="cpu优化">CPU优化</h3>
<p>启动过程中的代码归根到底是需要在 CPU 上执行的，CPU 耗时越多启动时间越长，这个 CPU 耗时不仅指主线程耗时，也包括子线程耗时，如果子线程执行任务太多，也会跟主线程竞争 CPU 时间片，导致主线程耗时变长。</p>
<p>CPU 负载治理，需要先获取启动过程中的 CPU 都被什么占用了，方法有很多，比如通过 /proc/self/stat 获取，simpleperf cpu-clock 统计，也可以使用  Perfetto 工具。</p>
<p>如果主线程占用 CPU 过高（比如超过30%），可以考虑将部分主线程任务移到子线程处理，充分利用 CPU 的多核资源。</p>
<p>如果子线程 CPU 占用过高，需要重点分析是否是必需的，非必需的建议延迟到启动完成以后，</p>
<h3 id="ipc优化">IPC优化</h3>
<p>Android 应用启动过程中存在大量与 AMS 和 WMS 的交互的IPC调用，而且 AMS 和 WMS 很多操作都是带锁的，如果有过多的 Binder 调用与 AMS、WMS 通信，SystemServer 就会出现大量的锁等待，从而导致启动时间增长。</p>
<p>统计启动过程中的 IPC 操作，可以使用 Android 自带 trace-ipc 统计，具体操作如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">adb shell am trace-ipc start</span><br><span class="line">adb shell am trace-ipc stop --dump-file /data/local/tmp/ipc-trace.txt</span><br><span class="line">adb pull /data/local/tmp/ipc-trace.txt</span><br></pre></td></tr></table></figure>
<p>或者使用动态代理 Hook android.os.BinderProxy的sTransactListener 对象（仅支持 Android 10 及以上）进行统计，可以更准确的控制开始结束时间，甚至可以线上数据统计。</p>
<p>举个例子，APP 启动中可能存在大量的 getPackageInfo IPC 调用，大部分都仅仅是为了获取 APP 的版本号，查看 PackageManagerService 的源码，可以看出其中存在大量的锁：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">private PackageInfo getPackageInfoInternal(<span class="built_in">String</span> packageName, long versionCode,</span><br><span class="line">            int flags, int filterCallingUid, int userId) &#123;</span><br><span class="line">    		......</span><br><span class="line">        <span class="comment">// 大量方法都是使用mPackages这个锁，很容易出现锁竞争</span></span><br><span class="line">        synchronized (mPackages) &#123; </span><br><span class="line">            <span class="comment">// Normalize package name to handle renamed packages and static libs</span></span><br><span class="line">            packageName = resolveInternalPackageNameLPr(packageName, versionCode);</span><br><span class="line">            .....</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于像版本号这种不变的参数，我们可以通过 hook PackageManager 给 getPackageInfo 方法增加缓存，这样业务调用获取版本号时直接返回对应的 PackageInfo 即可。但是 hook 毕竟还是有风险的，这里还是建议有获取版本号需求的组件，可以通过反射 ${package}.BuildConfig 的 VERSION_CODE 获取，或者通过上层业务传入。</p>
<h2 id="小技巧">小技巧</h2>
<h3 id="闪屏图片优化">闪屏图片优化</h3>
<p>APP 一般都会有闪屏，但是解析闪屏图片一般会造成 100ms 左右的耗时，其实我们可以利用 Android 提供的 StartingWindow 机制减少这部分耗时，StartingWindow 就是在 Activity 创建并初始化成功前显示一个预览窗口，这样保证页面能够快速打开，等待 Activity 显示第一帧后就会移除这个窗口。</p>
<p>StartingWindow 也是可以定制的，就是目标 Activity 的 Theme，把首页的 Theme 定制成闪屏图片，然后在 onCreate 中重新设置 Theme 为透明，即可去掉主线程解析闪屏图片的耗时了，相关代码参考如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//透明主题</span></span><br><span class="line"> &lt;style name=<span class="string">"AppTheme_noBg"</span>&gt;</span><br><span class="line">      &lt;item name=<span class="string">"android:windowBackground"</span>&gt;@color/transparent&lt;<span class="regexp">/item&gt;</span></span><br><span class="line"><span class="regexp"> &lt;/</span>style&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Activity onCreate 中设置透明主题</span></span><br><span class="line">protected <span class="keyword">void</span> onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">      setTheme(R.style.AppTheme_noBg);</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fileprovider优化">FileProvider优化</h3>
<p>有些 APP 启动过程中要安装很多 FileProvider，通过分析 FileProvider 源码可以发现，相比普通的 ContentProvider，FileProvider 在安装过程中会读取解析对应的 xml path 更耗时。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public <span class="keyword">void</span> attachInfo(Context context, ProviderInfo info) &#123;</span><br><span class="line">        <span class="keyword">super</span>.attachInfo(context, info);</span><br><span class="line">        ...</span><br><span class="line">        mStrategy = getPathStrategy(context, info.authority); <span class="comment">//读取解析xml路径文件</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>但是绝大部分 FileProvider 在启动过程中是没有用的，没有必要在启动过程中解析，我们可以想办法把这部分耗时去掉，延迟到需要用的时候在解析。</p>
<p><strong>优化方法：</strong> 将 FileProvider 统一移到一个空进程（该进程不会执行任何 sdk 初始化逻辑，资源占用小），到实际使用 FileProvider 时再在空进程里初始化，避免影响主进程启动时间</p>
<h2 id="黑科技">黑科技</h2>
<h3 id="资源文件重排">资源文件重排</h3>
<p>Linux 系统读取文件会先把文件内容加载到 pagecache 中，系统会先尝试从 pagecache 中读取，如果读取文件已经在 pagecache 中，则不会发生真实的磁盘 IO，而是直接从  pagecache 中读取，这就大大提升读的速度。同时，为了提升磁盘读取效率，Linux 采取了预读机制，预读其实就是利用了局部性原理，具体过程是：对于每个文件的第一个读请求，系统读入所请求的页面并读入紧随其后的少数几个页面。</p>
<p>所以如果启动过程中要读取的 apk 文件按实际加载顺序排列，就能充分利用 Linux 预读机制，提升预读命中率，减少启动过程中的IO等待，降低启动时间。</p>
<h3 id="dex2oat">Dex2Oat</h3>
<p>Android 通过 AOT(Ahead Of Time) 编译, 将 Java 字节码编译为机器码，运行时就跳过类验证、记载过程， 同样不会触发运行时 JIT 编译，减少 PageFault 时机，可以优化启动时间。Android 系统用于实现 AOT 编译的组件是 dex2oat， 由 PackageManagerService 系统服务调用。</p>
<p>但是由于系统编译任务有条件限制并不会实时编译，甚至不会当天编译， 我们可以手动触发编译行为， 尽可能提早 Dex2Oat 执行的时机，可以加速 App 升级前几天的启动性能。</p>
<h1>检测工具</h1>
<p>Perfetto、systrace、Profiler、Nanoscope、SimplePerf</p>
]]></content>
      <categories>
        <category>安卓笔记</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart异步编程</title>
    <url>/2020/01/06/Dart%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>本文简单介绍下 Future、async、await。</p>
<h2 id="future">Future</h2>
<p>Future 代表异步操作的结果，并且有两个状态：未完成、完成。</p>
<ul>
<li>未完成：在此状态下，Future 会等待异步操作结束或者 throw 一个异常。</li>
<li>完成：如果异步操作成功，Future 会返回一个值（ T、Void ）。相反，Future 会 throw 一个异常。</li>
</ul>
<p>Future 的例子：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="keyword">void</span>&gt; fetchUserOrder() &#123;</span><br><span class="line">  <span class="comment">// Imagine that this function is fetching user info from another service or database</span></span><br><span class="line">  <span class="keyword">return</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">3</span>), () =&gt; <span class="built_in">print</span>(<span class="string">'Large Latte'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  fetchUserOrder();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Fetching user order...'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Fetching user order...</span><br><span class="line">Large Latte</span><br></pre></td></tr></table></figure>
<p>在 main 方法中，虽然 fetchUserOrder 方法是先执行的，但是 fetchUserOrder 方法是返回 Future<void> 的异步方法（延迟了3秒），所以先执行了后面的 print 方法。由此可见 Future 是不会阻塞方法的执行的。</void></p>
<h2 id="async-await">async、await</h2>
<p>async 和 await 关键字提供了一种声明性的方式来定义异步函数并使用其结果，并且这两个关键字有两条使用准则：</p>
<ul>
<li>要定义异步函数，请在函数主体之前添加 async。</li>
<li>await 关键字只会在使用 async 声明的方法体内生效。</li>
</ul>
<p>使用方式如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="keyword">void</span>&gt; main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">await</span> createOrderMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个关键字的作用：</p>
<ul>
<li>async：将一个函数体标记为异步。</li>
<li>await：等待一个Future的执行结束后，再执行后续的代码。这意味着在异步函数体内，第一个await关键字之前的所有同步代码将立即执行。另外，可以使用await关键字来获取异步表达式的完整结果。</li>
</ul>
<p>下面看一个例子：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> printOrderMessage () <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Awaiting user order...'</span>);</span><br><span class="line">  <span class="keyword">var</span> order = <span class="keyword">await</span> fetchUserOrder();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Your order is: <span class="subst">$order</span>'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; fetchUserOrder() &#123;</span><br><span class="line">  <span class="comment">// Imagine that this function is more complex and slow.</span></span><br><span class="line">  <span class="keyword">return</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">4</span>), () =&gt; <span class="string">'Large Latte'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt;main() <span class="keyword">async</span> &#123;</span><br><span class="line">  countSeconds(<span class="number">4</span>);</span><br><span class="line">  <span class="keyword">await</span> printOrderMessage();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'main finish!!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can ignore this function - it's here to visualize delay time in this example.</span></span><br><span class="line"><span class="keyword">void</span> countSeconds(s) &#123;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">1</span> ; i &lt;= s; i++ ) &#123;</span><br><span class="line">      Future.delayed(<span class="built_in">Duration</span>(seconds: i), () =&gt; <span class="built_in">print</span>(i));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Awaiting user order...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">Your order <span class="keyword">is</span>: Large Latte</span><br><span class="line">main finish!!</span><br></pre></td></tr></table></figure>
<p>在 main 方法中，先执行了同步方法 countSeconds ，在 countSeconds 中执行了异步方法，每隔一秒打印1次，共执行4次，即4秒。接着继续方法 printOrderMessage ，在 printOrderMessage 中先执行了同步方法，进行了打印，接着因为有 await 字段出现，会等待 fetchUserOrder 这个异步方法执行结束后在向下执行。fetchUserOrder 执行结束之后，才执行了“ Your order is xxxx ”。最后在 main 方法中等待 printOrderMessage 方法执行结束后，执行了打印方法。</p>
<h2 id="业务场景">业务场景</h2>
<p>看一个简单的使用场景的省略代码。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span> data = <span class="built_in">List</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  fetchData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> fetchData() <span class="keyword">async</span> &#123;</span><br><span class="line">  data = <span class="keyword">await</span> HttpUtil.<span class="keyword">get</span>();</span><br><span class="line"></span><br><span class="line">  setState(() &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> ListContainer(</span><br><span class="line">    child: data.length&gt;<span class="number">0</span>?<span class="built_in">List</span>(</span><br><span class="line">      data: data,</span><br><span class="line">    ):<span class="keyword">null</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结自：<a href="https://dart.dev/codelabs/async-await" target="_blank" rel="noopener">https://dart.dev/codelabs/async-await</a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>FPS监控调研</title>
    <url>/2023/11/27/FPS%E7%9B%91%E6%8E%A7%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h1>定义</h1>
<p>某段连续时间 deltT 内渲染完成的帧数 n，那么 n / deltT 就是帧率（Frames Per Second）。</p>
<h1>四种方式</h1>
<p>Android没有提供直接获取帧率的方法，而是直接或者间接的提供了获取每一帧渲染耗时的功能，经过二次计算后得到帧率。</p>
<ul>
<li>SurfaceFlinger</li>
<li>Gfxinfo</li>
<li>FrameMetrics</li>
<li>Choreographer</li>
</ul>
<h2 id="surfaceflinger">SurfaceFlinger</h2>
<p>SurfaceFlinger服务运行在Android系统的System进程中，它负责管理Android系统的帧缓冲区（Frame Buffer），绘制应用程序的UI。Android应用程序会请求SurfaceFlinger服务创建Surface，在上面绘制自己的UI，然后将这个已经绘制好了UI的Surface渲染到设备显示屏上去。通过获取SurfaceFlinger的一些数据，我们可以计算出帧率。</p>
<ul>
<li>方法一：通过“<strong>adb shell dumpsys SurfaceFlinger --latency</strong>”命令，可以获得历史的127条帧绘制数据。</li>
<li>方法二：通过“<strong>service call SurfaceFlinger 1013</strong>”获取帧数1，在经过deltT时间后再次通过这个命令获取帧数2，使用（帧数2-帧数1）/deltT即可计算出帧率。</li>
</ul>
<p>优点：计算帧率的一个周期报过了CPU和GPU的渲染实现，所以计算结果准确</p>
<p>缺点：只能通过adb使用，没办法用于线上</p>
<h2 id="gfxinfo">Gfxinfo</h2>
<p>我们平常通过[设置]-&gt;[开发者选项]-&gt;[GPU呈现模式分析] -&gt;[在屏幕上显示为条形图] 这样的方式来观察页面的绘制情况，而“gfxinfo”命令就是将条形图数字化了。</p>
<p>在 5.0 上执行 gfxinfo 命令，得到的即为渲染一帧所经过的各个阶段的耗时情况：</p>
<p><strong>Draw: 表示在Java中创建显示列表部分中，OnDraw()方法占用的时间。</strong></p>
<p><strong>Process：表示渲染引擎执行显示列表所花的时间，view越多，时间就越长</strong></p>
<p><strong>Execute：表示把一帧数据发送到屏幕上排版显示实际花费的时间。其实是实际显示帧数据的后台缓存区与前台缓冲区交换后并将前台缓冲区的内容显示到屏幕上的时间。</strong></p>
<p><strong>Draw + Process + Execute = 完整显示一帧 ，这个时间要小于16ms才能保证每秒60帧。</strong></p>
<p>优点：计算帧率的一个周期报过了CPU和GPU的渲染实现，所以计算结果准确</p>
<p>缺点：这个命令可以在代码中通过反射的方式获取到数据，但是需要用户<strong>手动</strong>的在[设置]-&gt;[开发者选项]-&gt;[GPU呈现模式分析] -&gt;[在屏幕上显示为条形图] /[显示在adb shell dumpsys gfxinfo中]</p>
<h2 id="framemetrics">FrameMetrics</h2>
<p>虽然 FrameMetrics 与 Gfxinfo 的数据同源，但是二者在计算帧率时也有差别。FrameMetrics 获得的是单个帧的数据，正常情况下只能拿到渲染一帧的各个阶段的数据（加起来是该帧总耗时），但可以通过反射拿到FrameMetrics的mTimingData变量中的数据（该数据就是gfxinfo命令带framestats的结果）</p>
<p>优点：官方推荐，计算方式简单，可以获得绘制的各个阶段的起始时间和耗时。</p>
<p>缺点：api≥24</p>
<h2 id="choreographer">Choreographer</h2>
<p>Choreographer机制是Android 4.1加入的，用于同Vsync机制配合，实现统一调度界面绘图。一次屏幕刷新完成后，将产生 VSync 信号并通知 Choreographer。 Choreographer 收到通知依次处理 Input、Animation、Draw，这三个过程都是通过 FrameCallback 回调的方式完成的。在 Draw 过程中，具体是执行 ViewRootImpl#performTraversals() 方法，完成视图树的 measure、layout、draw 流程。 而 FrameCallback#doFrame(long frameTimeNanos) 方法中可以得到 VSync 到来的时间戳，这样就能得到连续两帧开始渲染之间的间隔，将该值近似作为上一帧的渲染耗时。 实现 FrameCallback 接口，并通过 Choreographer#postFrameCallback() 方法将其跟 Input、Animation、Draw 这些回调一起塞入主线程的消息队列，就能源源不断的获取每一帧的渲染时间戳，每一个 VSync 的时间戳代表一帧，这样可以得到某段时间内渲染完成的帧数，二者相除即可得到帧率。</p>
<p>优点：计算方式简单</p>
<p>缺点：</p>
<p>在Android 5.0之后，由主线程和Render Thread 线程共同完成一帧的绘制，其中又分两种情况（具体见 <a href="https://www.jianshu.com/p/bc1c1d2fadd1" target="_blank" rel="noopener">Android5.0中 hwui 中 RenderThread 工作流程</a> 文尾表述）：</p>
<ul>
<li>主线程在完成第一帧自己负责的部分后交给 Render Thread 线程，然后自己马不停蹄的继续绘制第二帧；</li>
<li>在完成第一帧自己负责的部分后交给 Render Thread 线程，然后等待 Render Thread 完成第一帧剩余的工作后在进行第二帧的绘制；</li>
</ul>
<p>一次滑动过程中，上述两种情况可能均存在，但是Choreographer只统计了主线程中的部分，而忽略了 Render 线程的部分，这样会导致得到的<strong>耗时偏小、帧率偏大</strong>。更进一步，既然一帧的绘制和渲染分布于两个线程， 那即使一帧的耗时综合大于 16.6 ms，只要位于 UI 线程部分的耗时不超过 16.6ms，那么就不影响 UI 线程绘制下一帧，但是会导致屏幕接着显示上一帧的内容，出现掉帧，而 Choreographer 仅凭帧耗时无法检测出这种掉帧。</p>
<h1>总结与分析</h1>
<p>Choreographer和FrameMetrics的方案比较容易实现，但是目前只采用了Choreographer方案收集数据。但就上面的调研结果来看，Choreographer的统计帧率偏大，另外Choreographer采用postFrameCallback()的方法是会源源不断的回调doFrame()方法（<strong>即使页面不在渲染</strong>），所以采用的是（连续时间内回调doFrame()方法的次数/这段时间）来计算帧率。而FrameMetrics只有<strong>在页面渲染</strong>的时候才会回调方法，所以采用的是（取回调方法中的渲染总耗时+之前的平均帧率*之前的回调次数）/当前回调次数来计算帧率。所以Choreographer和FrameMetrics之间的误差还在于当页面处于静止状态，不需要渲染时，Choreographer的计算结果会慢慢偏向于60帧，造成该页面整体流畅的假象。所以，采用FrameMetrics方案更准确。</p>
<p>思考：</p>
<p>一般来说，Choreographer和FrameMetrics方案都只是计算的平均FPS，平均值只能反应一组数据集中趋势的量数，但是平均值很容易受极值的影响，比如在一个滚动页面中，第一个页面FPS值较低，但是后续的页面FPS值很高，这样就会造成整体的平均FPS值偏高，发现不了存在的问题。所以思考能否引入多个指标来综合分析页面的流畅度？</p>
<p>改进：</p>
<p>新的改进方案中，引入了FPS方差、最多连续掉帧数、连续掉帧发生次数、掉帧率、严重掉帧率。</p>
<p><strong>FPS方差</strong></p>
<p>方差可以反应数据的波动性，用来度量数据的离散程度。那么对于上述例举的情况就能反映出来，整体的方差值偏大。</p>
<p><strong>最多连续掉帧数</strong></p>
<p>记录该页面内发生连续掉3帧及以上的现象，筛选出单次连续掉帧最多的一次。不管是平均值还是方差，都可能随着样本量的增多，导致某一个连续时间内的掉帧（某个view渲染耗时长）被忽视。记录最多连续掉帧数可以发现这种情况。</p>
<p><strong>连续掉帧发生次数</strong></p>
<p>记录该页面内发生连续掉3帧及以上现象的次数。用来发现是否页面内经常出现连续掉帧（某些view渲染耗时长导致）的情况。</p>
<p><strong>掉帧率</strong></p>
<p>记录帧率小于60的帧数，除以总的帧数。用来评估页面的流畅度。</p>
<p><strong>严重掉帧率</strong></p>
<p>记录帧率小于30的帧数，除以总的帧数。用来评估页面的流畅度。</p>
]]></content>
      <categories>
        <category>安卓笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Flutter for Android走读</title>
    <url>/2018/12/22/Flutter-for-Android%E8%B5%B0%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>Flutter官方文档有一篇专门为安卓开发者写的<a href="https://flutterchina.club/flutter-for-android/" target="_blank" rel="noopener">Flutter for Android</a>，此篇文章拿安卓相关概念与Flutter进行对比，从而帮助安卓开发者快速了解Flutter。本文目的是对此片文章关键信息进行记录。</p>
<h2 id="flutter-for-android">Flutter for Android</h2>
<h3 id="views">Views</h3>
<ul>
<li>Flutter中，Widget代替安卓的view的概念，并且任何东西都Widget。<strong>区别在于，Widget仅仅支持一帧，每一帧都会创建Widget实例树，相当于一次性绘制整个界面</strong>。Android中的View，在绘制结束之后不会重绘，除非使用invalidate方法。与Android的视图层次系统不同（在framework改变视图），而在Flutter中的widget是不可变的，这允许widget变得超级轻量。</li>
<li>Flutter中的Widget分为有状态的（StatefulWidget）和无状态的（StatelessWidgets），更新一个Widget需要使用新建一个StatefulWidget和一个State对象配合使用。<strong>这里要注意的重要一点是无状态和有状态 widget的核心特性是相同的。每一帧它们都会重新构建，不同之处在于StatefulWidget有一个State对象，它可以跨帧存储状态数据并恢复它</strong>。</li>
<li>布局方式只能通过布局树实现，不能像安卓样使用xml进行布局。</li>
<li>Widget是不可变的，没有addChild等方法，所以可以通过一个方法动态返回不同的Widget实现布局中的添加或者删除组件的功能。</li>
<li>Flutter中可以通过AnimationController和Animation（例如：CurvedAnimation）实现动画。</li>
<li>可以通过CustomPaint和CustomPainter替代安卓中的Canvas实现在屏幕上绘制自定义形状。</li>
<li>可以通过Widget的组合完成自定义控件（在安卓中是通过继承View）。</li>
</ul>
<h3 id="intents">Intents</h3>
<ul>
<li><strong>Flutter中不存在Intents的概念</strong>，与Native的整合中需要用到Intents，另外就是调用外部组件，如Camera或者File picker。Native可以通过MethodChannel与Flutter完成数据通信。</li>
<li>Flutter中，管理多个屏幕有两个核心概念和类：Route 和 Navigator。Route是应用程序的“屏幕”或“页面”的抽象（可以认为是Activity）， Navigator是管理Route的Widget。Navigator可以通过push和pop route以实现页面切换。</li>
<li>处理Flutter中所有路由的Navigator类可用于从已经push到栈的路由中获取结果（实现安卓中的startActivityForResult）。</li>
</ul>
<h3 id="异步ui">异步UI</h3>
<ul>
<li><strong>Dart是单线程执行模型</strong>，除非启动一个Isolate（在另外一个线程上运行Dart代码的方式），否则Dart代码将在UI线程中执行，并由事件循环驱动。</li>
<li><strong>Flutter是单线程的，运行一个事件循环</strong>，所以无法进行线程管理或者使用像安卓中AsyncTasks、IntentServices的功能。方法后面增加asyn标识，既可以使此方法异步执行（可以进行耗时操作，如网络请求）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">loadData() async &#123;</span><br><span class="line">  String dataURL = <span class="string">"https://jsonplaceholder.typicode.com/posts"</span>;</span><br><span class="line">  http.Response response = await http.get(dataURL);</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    widgets = JSON.decode(response.body);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>可以通过Isolates执行耗时或计算密集型任务</strong>。是一个独立的线程，不能与主线程共享内存。</li>
<li>网络请求可以使用http包。</li>
<li>通过Progress Indicator widget实现进度指示器。</li>
</ul>
<h3 id="项目结构">项目结构</h3>
<ul>
<li><strong>Flutter遵循像iOS这样简单的3种分辨率格式</strong>: 1x, 2x, and 3x（资源文件放到images中并且需要在pubspec.yaml中进行声明）。</li>
<li>字符串的存储的最好方式是新建一个Strings类，并且在里面存放static类型的string，然后通过Strings类引用字符。</li>
<li>Flutter中通过pubspec.yaml来管理依赖（Android中是gradle）。</li>
</ul>
<h3 id="activities和fragments">Activities和Fragments</h3>
<ul>
<li>在Flutter中Activity和Fragment都对应Widget的概念。</li>
<li>Flutter中可以通过挂接到WidgetsBinding观察并监听didChangeAppLifecycleState更改事件来监听生命周期事件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">生命周期事件是：</span><br><span class="line">resumed - 应用程序可见并响应用户输入。这是来自Android的onResume</span><br><span class="line">inactive - 应用程序处于非活动状态，并且未接收用户输入。此事件在Android上未使用，仅适用于iOS</span><br><span class="line">paused - 应用程序当前对用户不可见，不响应用户输入，并在后台运行。这是来自Android的暂停</span><br><span class="line">suspending - 该应用程序将暂时中止。这在iOS上未使用</span><br></pre></td></tr></table></figure>
<h3 id="layouts">Layouts</h3>
<ul>
<li>Flutter中可以通过Row和Column实现LinearLayout。</li>
<li>通过使用Column、Row和Stack的组合来实现RelativeLayout的效果。</li>
<li>Flutter中Listview对应安卓中ScrollView、Listview。Flutter实现notifyDataSetChanged需要在setState中创建一个新的List()，并且将所有旧数据复制到新列表中。</li>
<li>ListView.Builder相当于安卓中的RecyclerView。</li>
<li>Text widget上设置自定义字体，需要将字体文件夹放到assets文件夹中，然后在pubspec.yaml中声名。</li>
<li>Text的样式有一个对应TextStyle对象，可以在其中自定义许多参数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">color</span><br><span class="line">decoration</span><br><span class="line">decorationColor</span><br><span class="line">decorationStyle</span><br><span class="line">fontFamily</span><br><span class="line">fontSize</span><br><span class="line">fontStyle</span><br><span class="line">fontWeight</span><br><span class="line">hashCode</span><br><span class="line">height</span><br><span class="line">inherit</span><br><span class="line">letterSpacing</span><br><span class="line">textBaseline</span><br><span class="line">wordSpacing</span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过向Text Widget的装饰构造函数参数添加InputDecoration对象，完成输入框显示占位符文本。同样设置InputDecoration的errorText可以显示验证错误。</li>
</ul>
<h3 id="手势检测和触摸事件处理">手势检测和触摸事件处理</h3>
<ul>
<li>Flutter中可以通过Widget的onPressed事件完成点击事件的回调（setOnClickListener）。</li>
<li>如果Widget不支持事件监听，可以将改Widget包装到GestureDetector中，并处理onTap方法。</li>
<li>GestureDetector支持的手势动作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tap：onTapDown、onTapUp、onTap、onTapCancel</span><br><span class="line">Double tap：onDoubleTap</span><br><span class="line">长按：onLongPress</span><br><span class="line">垂直拖动：onVerticalDragStart、onVerticalDragUpdate、onVerticalDragEnd</span><br><span class="line">水平拖拽：onHorizontalDragStart、onHorizontalDragUpdate、onHorizontalDragEnd</span><br></pre></td></tr></table></figure>
<h3 id="数据库与本地存储">数据库与本地存储</h3>
<ul>
<li>可以通过插件Shared_Preferences来完成对Shared Preferences的操作。</li>
<li>在Flutter中，您<strong>可以使用SQFlite插件来访问SQFlite此功能</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Google支付脱坑指南</title>
    <url>/2018/12/20/Google%E6%94%AF%E4%BB%98%E8%84%B1%E5%9D%91%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>本文主要介绍使用aidl方式接入google支付时遇到的坑以及注意事项</p>
<ul>
<li>接入google pay的官方文档：<a href="https://developer.android.com/google/play/billing/index.html" target="_blank" rel="noopener">https://developer.android.com/google/play/billing/index.html</a></li>
<li>官方示例：<a href="https://github.com/googlesamples/android-play-billing" target="_blank" rel="noopener">https://github.com/googlesamples/android-play-billing</a></li>
</ul>
<p>结合文档与Demo对内购应该会有一个比较全面的理解。</p>
<h2 id="坑与解">坑与解</h2>
<ul>
<li>
<p>官方Demo中是在客户端中做了支付结果的校验，但推荐支付校验最好是放在服务端中处理。因为支付校验时需要利用专属的app_key，如果放在客户端有一定安全性风险。</p>
</li>
<li>
<p>在测试google pay的时候需要在developer console后台中创建一个beta或者alpha版本的应用，并且需要上传一个签名的apk，当然前提条件是必须要花25美金申请一个谷歌开发账号。另外需要注意的是此apk必须包含<code>&lt;uses-permission android:name=&quot;com.android.vending.BILLING&quot; /&gt;</code>权限，即内购权限。</p>
</li>
<li>
<p>当应用处于beta、alpha状态时，只有授权的测试者账号（google 账号）才能在google play中下载此apk。在下图1的地方进行添加测试者操作，添加完成后将2的链接分享给测试者，测试者进行授权操作便可以在google play中下载此apk
<img src="/2018/12/20/Google支付脱坑指南/20170401173134262.png" alt="123">
可能有的同学会问，那岂不是每次做一些改动是必须重新上传apk然后下载，再进行测试？其实只要保证运行的apk签名与developer console上传的apk签名一致，包名一致，版本号与版本名是上传过的版本号与版本名即可。上传过的版本号和版本名怎么理解呢？
<img src="/2018/12/20/Google支付脱坑指南/20170401173204247.png" alt>
举个例子如上图，我上传过两个版本，老版本version code=10 、verison name=1.5.3，新版本version code=11 verison name=1.5.3，只要本地运行apk的verison code、version name在上传过的各个版本之中就可以正常测试，如果随便写不存在version code、version name是无法正常调起的支付的。
需要注意的是Android Studio直接运行的签名是默认debug，要保持与 developer console 签名一致可以手动配置debug签名，这样直接通过 Android Studio 运行就可以直接进行支付测试。</p>
</li>
<li>
<p>可以利用google提供的特有的商品id进行静态响应测试，静态相应测试无需进行支付。</p>
</li>
<li>
<p>配置商品时需要注意的坑就是要将配置完成的商品状态改为<strong>激活状态</strong>，不然进行支付时一直提示需要登录。</p>
</li>
<li>
<p>进行真实测试时，测试的google账号必须绑定有海外购买能力的信用卡或者paypal。</p>
</li>
<li>
<p>不比担心花销，只要在developer console中配置测试账号，就可以进行真实测试但不会真的扣钱。配置的地方如下图。
<img src="/2018/12/20/Google支付脱坑指南/20170401173457771.png" alt></p>
</li>
</ul>
]]></content>
      <categories>
        <category>脱坑指北</category>
      </categories>
  </entry>
  <entry>
    <title>H5微信支付webview设置referer无效问题</title>
    <url>/2018/12/21/H5%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98webview%E8%AE%BE%E7%BD%AEreferer%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>安卓在接入H5微信支付时，需要在webview中手动设置referer，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map extraHeaders = <span class="keyword">new</span> HashMap();</span><br><span class="line">extraHeaders.put(<span class="string">"Referer"</span>, <span class="string">"商户申请H5时提交的授权域名"</span>);<span class="comment">//例如 http://www.baidu.com </span></span><br><span class="line">webView.loadUrl(targetUrl, extraHeaders);<span class="comment">//targetUrl为微信下单地址</span></span><br></pre></td></tr></table></figure>
<p>设置referer的原因是因为微信后端需要验证请求来源，所以如果这个地方没有去设置的话，将无法正常拉起支付，并且webview会跳转如下页面中
<img src="/2018/12/21/H5微信支付webview设置referer无效问题/20180210220103937_meitu_1.png" alt></p>
<p>但是在测试过程中发现一个兼容性问题：在4.4.4、4.4.3的设备上，下单时一直会跳转到上面的页面中，后来通过抓包发现设置的Referer没有生效。</p>
<h2 id="解决方案">解决方案</h2>
<p>经过研究发现了一个靠谱方案，那就是利用loadDataWithBaseURL方法代替loadUrl方法，通过js去请求微信下单Url，我们先看下loadDataWithBaseURL方法的具体描述如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadDataWithBaseURL</span><span class="params">(String baseUrl, String data, String mimeType, String encoding, String historyUrl)</span></span></span><br></pre></td></tr></table></figure>
<p>此方法入参data可以是Html代码片，baseUr为页面的基础Url，用来组织html中的相对路径。</p>
<h2 id="具体做法">具体做法</h2>
<p>我们在data这个参数中传入js代码片去请求微信下单Url，而baseUr设置为授权域名，这样请求微信下单Url时，referer自动会被设置为baseUrl（正常请求的referer默认就是请求的来源地址），最终实现代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="string">"4.4.3"</span>.equals(android.os.Build.VERSION.RELEASE))</span><br><span class="line">                || (<span class="string">"4.4.4"</span>.equals(android.os.Build.VERSION.RELEASE))) &#123;</span><br><span class="line">	<span class="comment">//兼容这两个版本设置referer无效的问题</span></span><br><span class="line">	view.loadDataWithBaseURL(<span class="string">"商户申请H5时提交的授权域名"</span>,</span><br><span class="line">	        <span class="string">"&lt;script&gt;window.location.href=\""</span> + targetUrl + <span class="string">"\";&lt;/script&gt;"</span>,</span><br><span class="line">	        <span class="string">"text/html"</span>, <span class="string">"utf-8"</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	Map&lt;String, String&gt; extraHeaders = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	extraHeaders.put(<span class="string">"Referer"</span>, <span class="string">"商户申请H5时提交的授权域名"</span>);</span><br><span class="line">	view.loadUrl(targetUrl, extraHeaders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过测试，以上代码可以在安卓4.4.X正常拉起H5微信支付，最后贴一下官方总结的微信H5支付常见问题汇总 <a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=15_4" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=15_4</a> 。希望本文能帮助到遇到相同问题的程序员们！</p>
]]></content>
      <categories>
        <category>脱坑指北</category>
      </categories>
  </entry>
  <entry>
    <title>JVM内存模型与垃圾回收小结</title>
    <url>/2019/11/27/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1>前言</h1>
<p>本文主要对 JVM 内存模型与垃圾回收机制进行小结，以便日后翻阅。</p>
<h1>JVM运行时数据区</h1>
<p>首先看下 JVM 的内存模型图</p>
<p><img src="/2019/11/27/JVM内存模型与垃圾回收小结/pasted-image.png" alt></p>
<ul>
<li>程序计数器：当前线程所执行的行号指示器。（线程私有-为了线程切换后能恢复到正确的执行位置）</li>
<li>虚拟机栈：Java 方法执行的内存模型-存储局部变量表，操作数栈，动态链接，方法出口等信息。（通常意义的“栈”内存，线程私有，每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用到执行完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程）</li>
<li>本地方法栈：为虚拟机使用到的 native 方法服务</li>
<li>方法区：即通常的代码区，存放运行时常量池、成员变量、静态变量、方法的信息以及方法的字节码。（运行时常量池：方法区的一部分。编译期生成的各种字面量和符号引用，在类加载后存放到运行时常量池；运行期间产生的新的常量也放入运行时常量池。）</li>
<li>堆：存放对象实例，所有的对象和数组都要在堆（通常意义的“堆”内存，Java 垃圾收集器管理的主要区域）</li>
</ul>
<p>为了解决重新新建 string 对象而占用内存的问题，会在堆内存中，新建一个 string pool 来存放 string。当使用双引号进行创建 string 的时候，首先会在 string pool 中查找是否有一样内容的 string，如果找到了就直接返回这个 string 的引用，否则会在 string pool 中新建一个 string ，并且返回这个 string 的引用，详情如下图所示。</p>
<p><img src="/2019/11/27/JVM内存模型与垃圾回收小结/pasted-image1.png" alt></p>
<h1>对象如何访问</h1>
<h2 id="通过句柄访问对象">通过句柄访问对象</h2>
<p><img src="/2019/11/27/JVM内存模型与垃圾回收小结/WechatIMG2.jpeg" alt></p>
<h2 id="通过直接指针访问对象">通过直接指针访问对象</h2>
<p><img src="/2019/11/27/JVM内存模型与垃圾回收小结/WechatIMG1.jpeg" alt></p>
<h1>垃圾收集</h1>
<p>垃圾回收技术主要解决三个问题：哪些内存需要回收？什么时候回收？如何回收？</p>
<h2 id="哪些内存需要回收？">哪些内存需要回收？</h2>
<p>程序计数器、虚拟机栈、本地方法栈，三个区域随线程而生，随线程而灭。栈中的方法，运行结束后，内存自然会回收。所以主要对“堆内存”进行回收。</p>
<h2 id="什么时候回收？">什么时候回收？</h2>
<p>当占用这部分堆内存的对象“已死”的时候进行回收。如何判断对象“已死”？</p>
<ul>
<li>引用计数算法给对象添加一个引用计数器（存在循环引用问题）</li>
<li>根搜索算法（主流）</li>
</ul>
<h3 id="根搜索算法">根搜索算法</h3>
<p>通过一系列称为 GC Roots 的对象最为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，但一个对象到 CG Roots 没有任何引用相连时，证明此对象不可用。</p>
<p><img src="/2019/11/27/JVM内存模型与垃圾回收小结/1575017103066-image.png" alt></p>
<p>如上图所示，Object5~Object7 不可用，可以被回收。</p>
<p>Java 语言中，可以作为 GC Roots 的对象：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中的引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>本地方法栈中 JNI（一般来说的 Native 方法）的引用的对象</li>
</ol>
<h2 id="怎么回收？">怎么回收？</h2>
<h3 id="标记清除算法">标记清除算法</h3>
<p><img src="/2019/11/27/JVM内存模型与垃圾回收小结/image14.png" alt></p>
<p>过程：</p>
<ol>
<li>首先标记出需要回收的对象。</li>
<li>统一回收掉所有被标记的对象。</li>
</ol>
<p>缺点：</p>
<ol>
<li>标记和清除的效率都不高。</li>
<li>会产生大量的碎片，而导致频繁的回收。</li>
</ol>
<h3 id="复制算法">复制算法</h3>
<p><img src="/2019/11/27/JVM内存模型与垃圾回收小结/image15.png" alt></p>
<p>过程：</p>
<ol>
<li>划分为两块相等的空间，每次只用一半</li>
<li>只扫描标记存活的对象</li>
<li>把存活的对象移到空闲空间</li>
<li>把原空间直接清除，下次交替执行</li>
</ol>
<p>优点：</p>
<ol>
<li>只需要扫描存活的对象，效率更高</li>
<li>不会产生碎片</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要浪费额外的内存作为复制区</li>
<li>当存活率较高时，复制算法效率会下降</li>
</ol>
<h3 id="标记整理算法">标记整理算法</h3>
<p><img src="/2019/11/27/JVM内存模型与垃圾回收小结/image16.png" alt></p>
<p>过程：</p>
<ol>
<li>标记可回收对象</li>
<li>让所有存活对象向一端移动，然后直接清除掉段边界以外的内存</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要更新每个对象的引用地址</li>
</ol>
<h3 id="分代收集算法">分代收集算法</h3>
<p><img src="/2019/11/27/JVM内存模型与垃圾回收小结/image17.png" alt></p>
<ul>
<li>新生代：每次垃圾收集时都发现有大批对象死区，少量存活，那就选用复制算法，只要付出少量存货对象的复制成本</li>
<li>老年代：对象存活率高，没有额外空间—标记清理或者标记—整理</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>React Hook</title>
    <url>/2022/07/28/React-Hook/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>RecyclerView实现item多类型布局和跨列</title>
    <url>/2018/12/21/RecyclerView%E5%AE%9E%E7%8E%B0item%E5%A4%9A%E7%B1%BB%E5%9E%8B%E5%B8%83%E5%B1%80%E5%92%8C%E8%B7%A8%E5%88%97/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>本文主要简单记录下RecyclerView如何实现item多类型布局和item跨列。</p>
<h2 id="item多类型布局">item多类型布局</h2>
<p>首先为RecyclerView设置layoutManger，因为下文要说到跨列，所以这里选用GridLayoutManager。然后为GridLayoutManager设置初始列数，这里设置为两列，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">manager = <span class="keyword">new</span> GridLayoutManager(<span class="keyword">this</span>, <span class="number">2</span>);</span><br><span class="line">recyclerView.setLayoutManager(manager);</span><br></pre></td></tr></table></figure>
<p>接着重写RecyclerView对应adapter的getItemViewType方法，将item的类型标识作为此方法的返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dataList.get(position).getItemType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在onCreateViewHolder方法中根据当前viewType的类型去返回对应的viewHolder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup viewGroup, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">	View view = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (viewType == ITEM_TYPE_1) &#123;</span><br><span class="line">	    view = View.inflate(mContext, R.layout.item_1, <span class="keyword">null</span>);</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">new</span> ViewHolder1(view);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (viewType == ITEM_TYPE_2) &#123;</span><br><span class="line">	    view = View.inflate(mContext, R.layout.item_2, <span class="keyword">null</span>);</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">new</span> ViewHolder2(view);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ViewHolder1(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此简单的item多类型布局就实现了。</p>
<h2 id="item跨列">item跨列</h2>
<p>item实现跨列主要通过重写GridLayoutManager的setSpanSizeLookup方法来实现，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">gridLayoutManager.setSpanSizeLookup(<span class="keyword">new</span> GridLayoutManager.SpanSizeLookup() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpanSize</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">int</span> spanSize;</span><br><span class="line">	    <span class="keyword">if</span> (adapter.getItemViewType(position) == ITEM_TYPE_1) &#123;</span><br><span class="line">	        spanSize = <span class="number">2</span>;<span class="comment">//跨2列</span></span><br><span class="line">	    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (adapter.getItemViewType(position) == ITEM_TYPE_2) &#123;</span><br><span class="line">	        spanSize = <span class="number">1</span>;<span class="comment">//跨1列</span></span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        spanSize = <span class="number">2</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> spanSize;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>此处的spanSize即为需要跨的列数，这里通过当前布局类型来设置对应的spanSize，至此完成跨列。</p>
]]></content>
      <categories>
        <category>安卓笔记</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title>View的Invalidate流程</title>
    <url>/2023/09/16/View%E7%9A%84Invalidate%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1>前言</h1>
<p>本文主要是整理下 View 执行 invalidate 方法的流程（软件绘制场景下）。</p>
<h2 id="时序图">时序图</h2>
<p>核心点是执行 view 的 doTraversal 之前会插入同步屏障，然后依赖 Choreographer postCallback 的监听系统的 vsync 信号，当信号到来时执行 doTraversal 方法，在此之后移除同步屏障，紧接着就是自顶向下执行 measure，layout，draw 方法。</p>
<p><img src="/2023/09/16/View的Invalidate流程/invalidate%E6%B5%81%E7%A8%8B.png" alt></p>
]]></content>
      <categories>
        <category>安卓笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Web缓存</title>
    <url>/2022/08/15/Web%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>本文总结下Cookie &amp; Web Storage</p>
<p><img src="/2022/08/15/Web缓存/web.png" alt></p>
]]></content>
      <categories>
        <category>H5基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/12/20/hello-world/</url>
    <content><![CDATA[<p>Hello world!</p>
]]></content>
  </entry>
  <entry>
    <title>应用启动流程</title>
    <url>/2023/07/30/%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本文主要介绍应用的冷启流程的主要流程。</p>
<h3 id="主要流程图">主要流程图</h3>
<p><img src="/2023/07/30/应用启动流程/main.jpg" alt></p>
<ul>
<li>startActivity() 通过Instrumentation 向 AMS 进程发起 startActivity() 请求</li>
<li>AMS收到启动请求后由 ActivityStarter 处理 Flags 和 Intent 信息,然后再由 ActivityStackSupervisor 和 ActivityStack 处理 Task 和 Stack 流程</li>
<li>在 ActivityStackSupervisor 中判断 app 进程是否存在，若不存在则请求 AMS 进程创建新进程，app 进程存在的情况请直接跳到第7步</li>
<li>AMS 进程通过 Socket 方式请求 Zygote fork 新进程</li>
<li>在新进程里创建 ActivityThread(主线程) 并开启 Looper 循环，同时将 ApplicationThread 绑定到 AMS</li>
<li>AMS 回调 ApplicationThread 的 bindApplication() 方法将自身与新进程绑定，并在 ActivityThread 的 handleBindApplication() 方法中创建应用的 Application</li>
<li>Application 创建成功后，AMS 调用 ActivityStackSupervisor#realStartActivityLocked 向ActivityThread 发送创建 Activity 请求</li>
<li>ActivityThread 利用 ClassLoader 去加载 Activity，并回调其生命周期方法。</li>
</ul>
]]></content>
      <categories>
        <category>安卓笔记</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>LruCache缓存图片研究小结</title>
    <url>/2018/12/20/LruCache%E7%BC%93%E5%AD%98%E5%9B%BE%E7%89%87%E7%A0%94%E7%A9%B6%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>上一篇研究了LinkedHashMap实现LRU策略，虽然通过上述方式来实现图片缓存可以优化内存的使用效率，但是这种方式也存在一些问题，例如，LinkedHashMap不是线程安全的，所以在操作时需要考虑线程安全问题。另外在缓存时，只能指定缓存数据条目的数量，不能指定缓存区的大小，如果需要缓存的图片都比较大，可能就会出现问题。</p>
<p>其实在Android SDK 中已经为我们提供了一个实现LRU策略的cache类，LruCache类，这个类封装了LinkedHashMap并且解决了LinkedHashMap中存在的问题，今天我们以LruCache缓存图片为例研究下这个类。</p>
<h2 id="lrucache">LruCache</h2>
<p>有一点需要提前说明下，今天我们研究的是android.support.v4.util包中的LruCache类而不是android.util包中也有一个LruCache类，这点需要提前说明下，不然很容易蒙圈，因为这两个类中有些方法实现是不同的。</p>
<p>首先我们看一下LruCache的成员变量，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;K, V&gt; map;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//当前容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//最大容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> putCount;<span class="comment">//put的次数 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> createCount;<span class="comment">//create的次数 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> evictionCount;<span class="comment">//回收次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hitCount;<span class="comment">//命中次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> missCount;<span class="comment">//丢失的次数</span></span><br></pre></td></tr></table></figure>
<p>再看下构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">	<span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造方法中初始化了maxSize和LinkedHashMap，并且LinkedHashMap为按照访问顺序排序（此部分请参照上一篇文章）。maxSize即为最大容量。</p>
<p>前面提到LruCache可以指定缓存区大小，这怎么实现呢？其实，实现起来很简单只要在初始化的时候重写LruCache提供的sizeOf方法即可，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> LRU_CACHE_SIZE = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">//4MB</span></span><br><span class="line">LruCache&lt;String,Bitmap&gt; lruCache=<span class="keyword">new</span> LruCache&lt;String,Bitmap&gt;(LRU_CACHE_SIZE) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> value.getByteCount();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先我们定义了LruCache的最大容量为4 * 1024 * 1024，即4M的空间，然后我们重写sizeOf方法，让这个方法返回Bitmap的字节数。为什么这样写就可以指定缓存区大大小呢？接下来我们看下比较重要的put和get方法，你就会明白了~</p>
<p>首先看下put方法的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null || value == null"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	V previous;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	    putCount++;</span><br><span class="line">	    size += safeSizeOf(key, value);</span><br><span class="line">	    previous = map.put(key, value);</span><br><span class="line">	    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">	        size -= safeSizeOf(key, previous);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">	    entryRemoved(<span class="keyword">false</span>, key, previous, value);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	trimToSize(maxSize);</span><br><span class="line">	<span class="keyword">return</span> previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法体中，我们发现当key或者value为空时会抛出异常，这部分和LinkedHashMap是不同的，说明LruCache类是不支持key或者value为空，并且在对map进行put操作时加了synchronized ，保证了线程安全。另外我们发现有如下操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">size += safeSizeOf(key, value);</span><br></pre></td></tr></table></figure>
<p>这部分看上去像对size（当前容量）的累加，我们继续进入到safeSizeOf方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">safeSizeOf</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = sizeOf(key, value);</span><br><span class="line">	<span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Negative size: "</span> + key + <span class="string">"="</span> + value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中看到了之前重写sizeOf方法，看到这里我想大家就明白了。**我们之前重写sizeOf方法让它返回bitmap的字节数，而在put方法中会对每次put进来的bimap的字节数利用size进行累加，这样我们利用size和maxSize进行比较，就可以得知当前容量是否大于最大容量，当大于时就可以进行删除最近最少少用的资源的操作了。**另外sizeOf默认情况下是返回1的，所以如果不重写sizeOf方法，LruCache也是进行“计数”的。</p>
<p>接着看put方法的代码，我们会发现如下操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">previous = map.put(key, value);</span><br><span class="line"><span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">	size -= safeSizeOf(key, previous);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们都知道，在对一个hashmap进行put操作的时候 ，如果put的key-value键值对中的key已经存在与map中，新put的value会覆盖旧value，并且会返回旧value。如果key不存在于map中，则会返回null。这里利用previous获取返回值，如果previous不为空，则当前容量会减去previous的大小，这部分比较好理解，其实就是防止同一个key对应新旧value的大小的重复叠加。</p>
<p>接着往下看，在previous不为空的时候，会调用 entryRemoved(false, key, previous, value) 方法，并且把previous传进去了，查看此方法，我们发现此方法并没有函数体，看来需要我们重写此方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">entryRemoved</span><span class="params">(<span class="keyword">boolean</span> evicted, K key, V oldValue, V newValue)</span></span></span><br></pre></td></tr></table></figure>
<p>根据前面所讲，我们可以在初始化的时候重写这个方法，来释放掉一个key对应的旧value所占用的资源，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LruCache&lt;String,Bitmap&gt; lruCache=<span class="keyword">new</span> LruCache&lt;String,Bitmap&gt;(LRU_CACHE_SIZE) &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">	        <span class="keyword">return</span> value.getByteCount();</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">entryRemoved</span><span class="params">(<span class="keyword">boolean</span> evicted, String key, Bitmap oldValue, Bitmap newValue)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(evicted==<span class="keyword">false</span>&amp;&amp;oldValue！=<span class="keyword">null</span>)&#123;</span><br><span class="line">	        oldValue.recycle();<span class="comment">//释放bitmap资源</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看到这里，可能会有疑问，在什么方法里会进行删除最近最少的操作呢？接着看put方法我们会发现trimToSize方法，答案其实就在这个方法里面。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//不断循环删除linkedHashMap首元素，也就是最近最少访问的条目，直到size小于最大容量或者map中已经没有数据</span></span><br><span class="line">	    K key;</span><br><span class="line">	    V value;</span><br><span class="line">	    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	        <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) &#123;</span><br><span class="line">	            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getClass().getName()</span><br><span class="line">	                    + <span class="string">".sizeOf() is reporting inconsistent results!"</span>);</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        <span class="keyword">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;<span class="comment">//直到当前容量小于最大容量 </span></span><br><span class="line">	            <span class="keyword">break</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();<span class="comment">//指向首元素</span></span><br><span class="line">	        key = toEvict.getKey();</span><br><span class="line">	        value = toEvict.getValue();</span><br><span class="line">	        map.remove(key);<span class="comment">//删除最近最少的entry</span></span><br><span class="line">	        size -= safeSizeOf(key, value);</span><br><span class="line">	        evictionCount++;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    entryRemoved(<span class="keyword">true</span>, key, value, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察方法体我们发现，当当前容量大于最大容量时，会不断删除首元素即最近最少访问的元素，然后重新计算当前容量大小。只有在当前容量小于最大容量或者map中没有数据的时候才会break出去。在代码的最后也会调用一次entryRemoved(true, key, value, null)方法，并且把因为空间不足而删除的元素的key和value传递进去，不过第一参数为true有别与先前调用时传递的false，所以根据第一参数区别我们就可以进行一些不一样的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">entryRemoved</span><span class="params">(<span class="keyword">boolean</span> evicted, String key, Bitmap oldValue, Bitmap newValue)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(evicted==<span class="keyword">false</span>&amp;&amp;oldValue!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	    oldValue.recycle();</span><br><span class="line">	&#125;<span class="keyword">if</span>(evicted==<span class="keyword">true</span>&amp;&amp;oldValue!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	    <span class="comment">//TODO 根据key value 进行二级缓存</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，put方法说明的比较详细，相信大家已经有了比较深的了解，接下来get方法我们加快点节奏。get方法源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;<span class="comment">//key 不允许为空</span></span><br><span class="line">	    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	V mapValue;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	    mapValue = map.get(key);</span><br><span class="line">	    <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">	        hitCount++;</span><br><span class="line">	        <span class="keyword">return</span> mapValue;</span><br><span class="line">	    &#125;</span><br><span class="line">	    missCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	    </span><br><span class="line">	V createdValue = create(key);<span class="comment">//根据key进行新建</span></span><br><span class="line">	<span class="keyword">if</span> (createdValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	    createCount++;</span><br><span class="line">	    mapValue = map.put(key, createdValue);</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;<span class="comment">//有返回值，说明key对应value已存在，需要进行重现赋值，即取消上一步操作</span></span><br><span class="line">	        map.put(key, mapValue);</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        size += safeSizeOf(key, createdValue);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">	    entryRemoved(<span class="keyword">false</span>, key, createdValue, mapValue);<span class="comment">//可以释放刚创建的createdValue</span></span><br><span class="line">	    <span class="keyword">return</span> mapValue;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    trimToSize(maxSize);</span><br><span class="line">	    <span class="keyword">return</span> createdValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察代码，我们发现其实lrucache方法中主要是对linkedhashmap进行get操作，这部分不清除的同学可以看下上一篇关于linkedhashmap的研究总结。我们重点研究下通过key获取到的value为空时的case。观察代码，如果如果出现上述情况，会新建一个createdValue,并且把createdValue put到map中，利用mapValue 获取put返回值，继续判断mapValue 是否为空，如果mapValue 不为空说明此时此key在map中存在对应的value,所以接下来需要进行重新赋值，让key对应的value为mapValue 而不是createdValue。如果mapValue为空，说明key对应的value确实为空，需要进行就是重新计算当前size的大小。在代码的最后会判断mapValue是否为空，如果mapValue不为空的时候，会调用entryRemoved方法，并把createdValue放在oldvalue的位置，因为此时createdValue所占的资源是无用的，所以我们可以在entryRemoved中释放createdValue。如果mapValue不为空又会进入到trimToSize方法中进行容量计算和删除“最近最少”。</p>
<p>好了，get也方法讲完了，最后看下remove方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	V previous;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	    previous = map.remove(key);</span><br><span class="line">	    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">	        size -= safeSizeOf(key, previous);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">	    entryRemoved(<span class="keyword">false</span>, key, previous, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察代码，基本上和get和put有异曲同工之妙，在这里就不重复阐述了。</p>
<h2 id="总结">总结</h2>
<p>比较重要的方法都讲完了，到此大家对lrucache应该有了一个全面的了解了吧~~接下来我们稍微总结下lrucache吧！</p>
<ul>
<li>LruCache封装了LinkedHashMap，提供了LRU缓存的功能，并且在关键操作加了synchronized ，实现了线程安全。</li>
<li>LruCache提供了trimToSize方法，当容量不足时会自动删除最近最少访问的键值对。</li>
<li>LruCache提供了entryRemoved(boolean evicted, K key, V oldValue, V newValue)方法,通过重写这个方，结合put,get,remove方法我们可以做更多的事情。</li>
<li>LruCache不允许空键值；</li>
<li>LruCache提供了sizeof方法，重写这个方法可以实现指定缓存区大小，而不是像LinkedHashMap一样只能指定缓存条目数。</li>
</ul>
]]></content>
      <categories>
        <category>安卓笔记</category>
      </categories>
  </entry>
  <entry>
    <title>简单方式实现无限轮播Banner</title>
    <url>/2018/12/25/%E7%AE%80%E5%8D%95%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本文主要介绍一种简单实现无限轮播banner的方式。先来看下最后的效果如下:</p>
<p><img src="/2018/12/25/简单方式实现轮播控件/bannergif.gif" alt></p>
<h2 id="思路">思路</h2>
<p>实现无限轮播思路很简单：基础控件肯定是选用viewpager，然后结合假数据与viewpager的特殊生命周期方法<strong>onPageSelected</strong>与<strong>onPageScrollStateChanged</strong>，最终实现无限轮播效果。</p>
<h2 id="假数据">假数据</h2>
<p>所谓假数据，就是在原始imageView数组最前与最后各加一个假数据，既<strong>在原imageView数组的最前面增加一个与原最后一个imageView相同的imageView，同理在原imageView数组最后增加一个与原始第一个imageView相同的imageView</strong>，这样在最后一帧和第一帧进行切换时就会产生一种轮播的假象。结合下图应该就会比较容易理解。
<img src="/2018/12/25/简单方式实现轮播控件/banner.png" alt="banner"></p>
<h2 id="具体实现">具体实现</h2>
<p>有了上文提到的假数据之后，在最后一张图片向右切换时，滑动过程中漏出来的是假的第一张图片，而当这张图片完全展示出来之后，我们需要将整个viewpager定位到index为1的真正的第一张图片。同理，在由第一张图片向左切换时，漏出的是假的最后一张图片，而当这张图片完全展示后，我们需要将整个viewpager定位到index为3的图片。</p>
<p>ps：viewpager的index切换使用了<code>mPager.setCurrentItem(pageIndex, false);</code>方法，这样用户肉眼无法看出来banner进行了切换。</p>
<p>根据上面的思路，现在需要实现一个index的简单计算。这里选择在viewpager的onPageSelected方法来实现index的计算。为什么要选择这个方法呢？我们先来看下官方对这个方法给出的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method will be invoked when a new page becomes selected. Animation is not</span></span><br><span class="line"><span class="comment"> * necessarily complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> position Position index of the new selected page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> position)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以看出这个方法是在新的一页被选择后调用，并且会把被选择的position作为参数传入，所以在我们在这个方法上可以轻易的计算出我们希望的index，具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	pageIndex = i;<span class="comment">//i取值从0~4，3个原始数据2个假数据</span></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> imageViewSize = mImageViews.size();<span class="comment">//imageView的总数</span></span><br><span class="line">	<span class="keyword">if</span> (FAKE_ITEM_COUNT == <span class="number">2</span> &amp;&amp; imageViewSize &gt; <span class="number">1</span>) &#123;<span class="comment">//其中FAKE_ITEM_COUNT是指两个假数据</span></span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span>) &#123;<span class="comment">// 当视图在第一个时，将页面号设置为图片的最后一张</span></span><br><span class="line">		    pageIndex = imageViewSize - FAKE_ITEM_COUNT;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == mImageViews.size() - <span class="number">1</span>) &#123;<span class="comment">// 当视图在最后一个时,将页面号设置为图片的第一张</span></span><br><span class="line">		    pageIndex = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合代码注释，理解起来应该很容易，这里就不在赘述。现在计算好了index，我们最后只需要在合适的时机进行切换就大功告成了。这个合适的时机就是viewpager滑停的时候，整个实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == ViewPager.SCROLL_STATE_IDLE) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (mPager.getCurrentItem() != pageIndex) &#123;</span><br><span class="line">	        mPager.setCurrentItem(pageIndex, <span class="keyword">false</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解起来也很容易，既当viewpager滑停后，如果viewpager当前的index与当前我们计算的pageIndex不同时就把viewpager切换到pageIndex的位置（index=0，pageIndex=3的场景和index=4，pageIndex=1的场景），这样就实现了无限轮播。</p>
<h2 id="自动播放">自动播放</h2>
<p>实现自动播放的方式是通过handler发一个延迟消息，而在handler的消息处理中只要去设置当前index+1即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> position = mPager.getCurrentItem() + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (position &gt;= mPager.getAdapter().getCount()) &#123; <span class="comment">// 滑到底就再滑到开头</span></span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">mPager.setCurrentItem(position);</span><br></pre></td></tr></table></figure>
<p>最后贴一下整个Demo的地址</p>
<p><a href="https://github.com/PeterXiaoWang/BannerView" target="_blank" rel="noopener">https://github.com/PeterXiaoWang/BannerView</a></p>
]]></content>
      <categories>
        <category>安卓笔记</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin协程总结</title>
    <url>/2020/06/03/kotlin%E5%8D%8F%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1>Kotlin 协程</h1>
<h2 id="起因">起因</h2>
<p>最近发现了一个库，非常全面的介绍了协程在日常开发中的真实使用场景，地址是：<a href="https://github.com/LukasLechnerDev/Kotlin-Coroutine-Use-Cases-on-Android%E3%80%82" target="_blank" rel="noopener">https://github.com/LukasLechnerDev/Kotlin-Coroutine-Use-Cases-on-Android。</a></p>
<p>这个repo的介绍是：🎓 Learning Kotlin Coroutines for Android by example. 🚀 Sample implementations for real-world Android use cases. 🛠 Unit tests included!</p>
<p>整体来说，这个repo的质量非常良心，非常值得学习。</p>
<h2 id="协程的定义">协程的定义</h2>
<blockquote>
<p>协程的开发人员 Roman Elizarov 是这样描述协程的：协程就像非常轻量级的线程。</p>
</blockquote>
<blockquote>
<p>线程是由系统调度的，线程切换或线程阻塞的开销都比较大。</p>
</blockquote>
<blockquote>
<p>而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。</p>
</blockquote>
<blockquote>
<p>所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。</p>
</blockquote>
<p>协程是一种并发设计模式，可以在 Android 平台上使用它来简化异步执行的代码。</p>
<p>协程是一种编程思想，并不局限于特定的语言。</p>
<h2 id="基础">基础</h2>
<h3 id="coroutinescope">CoroutineScope</h3>
<p>CoroutinesScope 负责追踪通过 launch 或者 async 创建的协程。为了确保所有的协程都会被追踪，Kotlin 不允许在没有使用 CoroutinesScope 的情况下启动新的协程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val scope = CoroutineScope(Job() + Dispatchers.Main)</span><br><span class="line"></span><br><span class="line">val job = scope.launch &#123;</span><br><span class="line">    //新的协程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当创建 CoroutinesScope 的时候，需要传入 CoroutineContext 来作为构造函数的的参数。</p>
<h3 id="coroutinecontext">CoroutineContext</h3>
<p>CoroutineContext 是一组用于定义协程行为的元素。它的构成是：</p>
<ul>
<li>Job：控制协程的声明周期</li>
<li>CoroutineDispatcher：向合适的线程发布任务</li>
<li>CoroutineName：协程的名称</li>
<li>CoroutineExceptionHandler：处理未被捕获的异常</li>
</ul>
<h3 id="job">Job</h3>
<p>要想了解Job，那么就要先了解协程的启动方式。</p>
<h4 id="启动新的协程">启动新的协程</h4>
<p>有多种方式能够启动协程</p>
<p>1.lanuch 构建器它可以启动新的协程而不将结果返回给调用方。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val scope = CoroutineScope(Job() + Dispatchers.Main)</span><br><span class="line">val job =  scope.launch &#123; </span><br><span class="line">    //新的协程</span><br><span class="line">    fetchDoc(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.async 构建器可以启动新的协程，并且允许使用一个await的挂起函数返回result。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val scope = CoroutineScope(Job() + Dispatchers.Main)</span><br><span class="line">scope.launch &#123;</span><br><span class="line">    val jobWithResult = async &#123; fetchDoc(1) &#125;.await()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.coroutineScope、supervisorScope 构建器可以在suspend function 方法中来启动多个协程（coroutineScope 构造器和 CoroutineScope 这两个的区别只是一个字符之差，但它们却是完全不同的东西），coroutineScope构建器中启动的所有的协程完成任务之后，外层方法才会返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val scope = CoroutineScope(Job() + Dispatchers.Main)</span><br><span class="line">scope.launch &#123;</span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        launch &#123; fetchDoc(1) &#125;</span><br><span class="line">        async &#123; fetchDoc(2) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="启动参数">启动参数</h4>
<p>lanuch的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public fun CoroutineScope.launch(</span><br><span class="line">    context: CoroutineContext = EmptyCoroutineContext,</span><br><span class="line">    start: CoroutineStart = CoroutineStart.DEFAULT,</span><br><span class="line">    block: suspend CoroutineScope.() -&gt; Unit</span><br><span class="line">): Job</span><br></pre></td></tr></table></figure>
<p>async 和 lanuch 中的构造函数中 CoroutineStart 参数会指定协程的启动方式：</p>
<ul>
<li>CoroutineStart.DEFAULT 默认模式，创建就启动</li>
<li>CoroutineStart.LAZY 懒加载模式，需要自行手动启动</li>
<li>CoroutineStart.ATOMIC 自动模式，跟默认模式类似，区别是启动之前，没办法取消</li>
<li>CoroutineStart.UNDISPATCHED 跟自动模式类似，区别是直到第一个挂起点，才会切换上下文（实验性的）</li>
</ul>
<h4 id="job的生命周期">Job的生命周期</h4>
<p>Job用于处理协程，对于每一个通过 lanuch 或者 async 创建的协程，它会返回一个 Job 实例，该实例是协程的唯一标识，并且负责管理协程的生命周期。</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_png/rFWVXwibLGtzSGkhS9F6JjSwricHPI14dKsibvYYppiaNH5XTGuicKuGibalo4d3VfZT7P2AS8Zic4yKibXJ4MPlJfCrkg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" target="_blank" rel="noopener">Job生命周期</a></p>
<p>一个任务可以包含一系列状态: 新创建 (New)、活跃 (Active)、完成中 (Completing)、已完成 (Completed)、取消中 (Cancelling) 和已取消 (Cancelled)。虽然我们无法直接访问这些状态，但是我们可以访问 Job 的属性: isActive、isCancelled 和 isCompleted。</p>
<p>Job的方法:</p>
<ul>
<li>job.start 启动一个协程</li>
<li>job.cancel 取消一个协程</li>
<li>job.join 等待协程执行结束（Suspend function 'join' should be called only from a coroutine or another suspend function）</li>
</ul>
<p>Job的扩展函数:</p>
<ul>
<li>cancelAndJoin 功能=先cancel，然后join，即取消协程并且等待被取消的协程完成</li>
</ul>
<h3 id="coroutinedispatcher">CoroutineDispatcher</h3>
<p>Kotlin 提供了三个调度器:</p>
<ul>
<li>Dispatchers.Main：运行在 Android 的主线程中，用来处理 UI 交互和一些轻量级的任务。eg：调用 suspend 函数、调用 UI 函数、更新 LiveData</li>
<li><a href="http://Dispatchers.IO" target="_blank" rel="noopener">Dispatchers.IO</a>：非主线程，专为磁盘和 IO 进行优化。eg：数据库操作、文件读写、网络处理</li>
<li>Dispatchers.Default：非主线程，专为 CPU 密集型任务进行了优化。eg：数据排序、JSON 数据解析、处理差异判断</li>
</ul>
<h2 id="特殊">特殊</h2>
<h3 id="async">async</h3>
<p>async 可以启动一个协程，并且会返回一个包含结果的 Deferred（一个轻量级的非阻塞 future），可以通过 .await() 方法获取其结果（await 方法是一个挂起函数，官方解释：Awaits for completion of this value without blocking a thread and resumes when deferred computation is complete,returning the resulting value or throwing the corresponding exception if the deferred was cancelled.），但是 Deferred 也是一个 Job。<strong>另外通过 async 启动的协程可以和其他的所有协程一起并发工作。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">viewModelScope.launch &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                coroutineScope &#123;</span><br><span class="line">                    val oreoFeaturesDeferred = async &#123; mockApi.getAndroidVersionFeatures(27) &#125;</span><br><span class="line">                    val pieFeaturesDeferred = async &#123; mockApi.getAndroidVersionFeatures(28) &#125;</span><br><span class="line">                    val android10FeaturesDeferred = async &#123; mockApi.getAndroidVersionFeatures(29) &#125;</span><br><span class="line"></span><br><span class="line">                    val oreoFeatures = oreoFeaturesDeferred.await()</span><br><span class="line">                    val pieFeatures = pieFeaturesDeferred.await()</span><br><span class="line">                    val android10Features = android10FeaturesDeferred.await()</span><br><span class="line"></span><br><span class="line">                    val versionFeatures = listOf(oreoFeatures, pieFeatures, android10Features)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (exception: Exception) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以是用 .awaitAll() 获取多个返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">viewModelScope.launch &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        val recentVersions = mockApi.getRecentAndroidVersions()</span><br><span class="line">        val versionFeatures = recentVersions</span><br><span class="line">            .map &#123; androidVersion -&gt;</span><br><span class="line">                async &#123; mockApi.getAndroidVersionFeatures(androidVersion.apiLevel) &#125;</span><br><span class="line">            &#125;.awaitAll()</span><br><span class="line">        uiState.value = UiState.Success(versionFeatures)</span><br><span class="line">    &#125; catch (exception: Exception) &#123;</span><br><span class="line">        uiState.value = UiState.Error(&quot;Network Request failed&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="suspend">suspend</h3>
<p>详情：<a href="https://mp.weixin.qq.com/s/uJXawdis81zGlZPijkHLhw" target="_blank" rel="noopener">链接</a></p>
<p>添加了 suspend 修饰符的方法称为挂起函数。我们都知道挂起函数会完成了所有工作时候才会返回，并且不会阻塞线程。利用挂起函数可以用命令式代码替代回调的方式。</p>
<p>不同于回调，协程提供了一种简单的方式来实现线程间的切换以及对异常的处理。但是，在我们把一个函数写成挂起函数时，编译器在内部究竟做了什么事呢？</p>
<p>背后的原理：Kotlin 编译器会把挂起函数使用<strong>有限状态机</strong>转换为一种优化版回调。也就是说，编译器会帮您实现这些回调！</p>
<p>几个关键点：</p>
<ul>
<li>Continuation ：编译器将会在函数签名中使用额外的 completion 参数 (Continuation 类型) 来代替 suspend 修饰符。而该参数将会被用于向调用该挂起函数的协程返回结果。</li>
<li>生命状态机 ：Kotlin 编译器会确定函数何时可以在内部挂起，每个挂起点都会被声明为有限状态机的一个状态，每个状态又会被编译器用标签表示。</li>
<li>编译器会创建一个私有类用户保存必要数据&amp;递归调用原始函数来回复执行。</li>
</ul>
<p>原始代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">suspend fun loginUser(userId: String, password: String): User &#123;</span><br><span class="line">  val user = userRemoteDataSource.logUserIn(userId, password)</span><br><span class="line">  val userDb = userLocalDataSource.logUserIn(user)</span><br><span class="line">  return userDb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器编译过后的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun loginUser(userId: String?, password: String?, completion: Continuation&lt;Any?&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    class LoginUserStateMachine(</span><br><span class="line">        // completion 参数是调用了 loginUser 的函数的回调</span><br><span class="line">        completion: Continuation&lt;Any?&gt;</span><br><span class="line">    ): CoroutineImpl(completion) &#123;</span><br><span class="line">        // 要在整个挂起函数中存储的对象</span><br><span class="line">        var user: User? = null</span><br><span class="line">        var userDb: UserDb? = null</span><br><span class="line">        // 所有 CoroutineImpls 都包含的通用对象</span><br><span class="line">        var result: Any? = null</span><br><span class="line">        var label: Int = 0</span><br><span class="line">        // 这个函数再一次调用了 loginUser 来切换</span><br><span class="line">        // 状态机 (标签会已经处于下一个状态) </span><br><span class="line">        // result 将会是前一个状态的计算结果</span><br><span class="line">        override fun invokeSuspend(result: Any?) &#123;</span><br><span class="line">            this.result = result</span><br><span class="line">            loginUser(null, null, this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val continuation = completion as? LoginUserStateMachine ?: LoginUserStateMachine(completion)</span><br><span class="line"></span><br><span class="line">    when(continuation.label) &#123;</span><br><span class="line">        0 -&gt; &#123;</span><br><span class="line">            // 错误检查</span><br><span class="line">            throwOnFailure(continuation.result)</span><br><span class="line">            // 下次 continuation 被调用时, 它应当直接去到状态 1</span><br><span class="line">            continuation.label = 1</span><br><span class="line">            // Continuation 对象被传入 logUserIn 函数，从而可以在结束时恢复 </span><br><span class="line">            // 当前状态机的执行</span><br><span class="line">            userRemoteDataSource.logUserIn(userId!!, password!!, continuation)</span><br><span class="line">        &#125;</span><br><span class="line">        1 -&gt; &#123;</span><br><span class="line">            // 检查错误</span><br><span class="line">            throwOnFailure(continuation.result)</span><br><span class="line">            // 获得前一个状态的结果</span><br><span class="line">            continuation.user = continuation.result as User</span><br><span class="line">            // 下次这 continuation 被调用时, 它应当直接去到状态 2</span><br><span class="line">            continuation.label = 2</span><br><span class="line">            // Continuation 对象被传入 logUserIn 方法，从而可以在结束时恢复 </span><br><span class="line">            // 当前状态机的执行</span><br><span class="line">            userLocalDataSource.logUserIn(continuation.user, continuation)</span><br><span class="line">        &#125;</span><br><span class="line">        2 -&gt; &#123;</span><br><span class="line">            // 错误检查</span><br><span class="line">            throwOnFailure(continuation.result)</span><br><span class="line">            // 获取前一个状态的结果</span><br><span class="line">            continuation.userDb = continuation.result as UserDb</span><br><span class="line">            // 恢复调用了当前函数的执行</span><br><span class="line">            continuation.cont.resume(continuation.userDb)</span><br><span class="line">        &#125;</span><br><span class="line">        else -&gt; throw IllegalStateException(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="runblocking">runBlocking</h3>
<p>runBlocking 也可以启动一个新的协程，但是调用了 runBlocking 的主线程会一直 <strong>阻塞</strong> 直到 runBlocking 内部的协程执行完毕。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun main() &#123;**</span><br><span class="line">    GlobalScope.launch &#123; // 在后台启动一个新的协程并继续</span><br><span class="line">        delay(1000L)</span><br><span class="line">        println(&quot;World!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Hello,&quot;) // 主线程中的代码会立即执行</span><br><span class="line">    runBlocking &#123;     // 但是这个表达式阻塞了主线程</span><br><span class="line">        delay(2000L)  // ……我们延迟 2 秒来保证 JVM 的存活</span><br><span class="line">    &#125; </span><br><span class="line">    println(&quot;main thread end.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello,</span><br><span class="line">World!</span><br><span class="line">main thread end.</span><br></pre></td></tr></table></figure>
<h3 id="withcontext">withContext</h3>
<p>不会创建协程，在指定协程上运行。会改变指定协程的上下文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">launch(UI) &#123;</span><br><span class="line">    updateUI()</span><br><span class="line">    val result = withContext(IO) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    setView(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>withContext 同回调或者是提供主线程安全特性的 RxJava 相比的话，性能是差不多的。在某些情况下，甚至还可以优化 withContext 调用，让它的性能超越基于回调的等效实现。如果某个函数需要对数据库进行 10 次调用，您可以使用外部 withContext 来让 Kotlin 只切换一次线程。这样一来，即使数据库的代码库会不断调用 withContext，它也会留在同一调度器并跟随快速路径，以此来保证性能。此外，在 Dispatchers.Default 和 <a href="http://Dispatchers.IO" target="_blank" rel="noopener">Dispatchers.IO</a> 中进行切换也得到了优化，以尽可能避免了线程切换所带来的性能损失。</p>
<p>withContext 和 async{}.await 的性能对比：</p>
<p><a href="https://stackoverflow.com/questions/50230466/kotlin-withcontext-vs-async-await" target="_blank" rel="noopener">Kotlin: withContext() vs Async-await</a></p>
<h3 id="原始挂起函数">原始挂起函数</h3>
<p>delay、yield、await等</p>
<h2 id="参考：">参考：</h2>
<ul>
<li><a href="https://www.kotlincn.net/docs/reference/coroutines/coroutines-guide.html" target="_blank" rel="noopener">https://www.kotlincn.net/docs/reference/coroutines/coroutines-guide.html</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652052998&amp;idx=2&amp;sn=18715a7e33b7f7a5878bd301e9f8f935&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652052998&amp;idx=2&amp;sn=18715a7e33b7f7a5878bd301e9f8f935&amp;scene=21#wechat_redirect</a></li>
<li><a href="https://mp.weixin.qq.com/s/wzSi7UrFK6iQV2MA2OCwew" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wzSi7UrFK6iQV2MA2OCwew</a></li>
</ul>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>通过LinkedHashMap缓存图片并实现LRU策略</title>
    <url>/2018/12/20/%E9%80%9A%E8%BF%87LinkedHashMap%E7%BC%93%E5%AD%98%E5%9B%BE%E7%89%87%E5%B9%B6%E5%AE%9E%E7%8E%B0LRU%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>在Android开发过程中，实现图片缓存是一个很重要的问题，如果处理不当很容易引起OOM等问题。很多图片加载框架中都会使用LRU机制来优化内存使用率。今天我们就看下通过LinkedHashMap如何实现LRU机制。</p>
<p>LRU（Least Recently Used）策略,即当内存使用不足时，把最近最少使用的数据从缓存中移除，保留使用最频繁的数据。</p>
<h2 id="linkedhashmap">LinkedHashMap</h2>
<p><img src="/2018/12/20/通过LinkedHashMap缓存图片并实现LRU策略/20150706170820591.png" alt></p>
<p>LinkedHashMap，它继承与HashMap，底层使用哈希表与双向链表来保存所有元素，上图即为一个双向链表。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。在初始化一个LinkedHashMap时可以指定accessOrder值来指定链表的排序策略，当accessOrder为false的时候链表按插入顺序排序，默认为false，当为true的时候按访问顺序排序，什么是按访问顺序排序呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实按访问顺序排序就是指在调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。这部分源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">	    HashMapEntry&lt;K, V&gt; e = entryForNullKey;</span><br><span class="line">	    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">	        makeTail((LinkedEntry&lt;K, V&gt;) e);</span><br><span class="line">	    <span class="keyword">return</span> e.value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> hash = Collections.secondaryHash(key);</span><br><span class="line">	HashMapEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">	<span class="keyword">for</span> (HashMapEntry&lt;K, V&gt; e = tab[hash &amp; (tab.length - <span class="number">1</span>)];</span><br><span class="line">	        e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">	    K eKey = e.key;</span><br><span class="line">	    <span class="keyword">if</span> (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) &#123;</span><br><span class="line">	        <span class="keyword">if</span> (accessOrder)</span><br><span class="line">	            makeTail((LinkedEntry&lt;K, V&gt;) e);</span><br><span class="line">	        <span class="keyword">return</span> e.value;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看源码我们发现，不管keys是否为空，在accessOrder为true（即按访问顺序排序）后，会先执行makeTail方法，然后再返回元素的Value。我们继续跟到makeTail方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeTail</span><span class="params">(LinkedEntry&lt;K, V&gt; e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Unlink e</span></span><br><span class="line">	e.prv.nxt = e.nxt;</span><br><span class="line">	e.nxt.prv = e.prv;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Relink e as tail</span></span><br><span class="line">	LinkedEntry&lt;K, V&gt; header = <span class="keyword">this</span>.header;</span><br><span class="line">	LinkedEntry&lt;K, V&gt; oldTail = header.prv;</span><br><span class="line">	e.nxt = header;</span><br><span class="line">	e.prv = oldTail;</span><br><span class="line">	oldTail.nxt = header.prv = e;</span><br><span class="line">	modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察makeTail的函数体，我们很容易发现这是一个对双向链表中一个元素解绑后与header关联的代码，经过操作后，当前元素会被插入到链表尾部。看到这里，我想大家就明白了为什么通过get方法会使链表按照按访问顺序排序。那当我们put数据的时候又会发生什么呢？通过源码我们发现，当我们put数据的时候，会先执行hashmap的put方法中，这是因为LinkedHashMap并没用重写这个方法而是重写了put方法中所调用的addNewEntry和addNewEntryForNullKey等方法。我们主要看下addNewEntry的函数体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">addNewEntry</span><span class="params">(K key, V value, <span class="keyword">int</span> hash, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	LinkedEntry&lt;K, V&gt; header = <span class="keyword">this</span>.header;</span><br><span class="line">	</span><br><span class="line">	LinkedEntry&lt;K, V&gt; eldest = header.nxt;</span><br><span class="line">	<span class="keyword">if</span> (eldest != header &amp;&amp; removeEldestEntry(eldest)) &#123;</span><br><span class="line">	    remove(eldest.key);</span><br><span class="line">	&#125;</span><br><span class="line">	    </span><br><span class="line">	LinkedEntry&lt;K, V&gt; oldTail = header.prv;</span><br><span class="line">	LinkedEntry&lt;K, V&gt; newTail = <span class="keyword">new</span> LinkedEntry&lt;K,V&gt;(</span><br><span class="line">	        key, value, hash, table[index], header, oldTail);</span><br><span class="line">	table[index] = oldTail.nxt = header.prv = newTail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addNewEntry方法中首先会获取头指针的下一个元素，并定义为eldest,从字面上理解应该是最老的元素，结合前面get方法的介绍也比较好理解为什么头指针下一个元素会是”最老的“。if中的第一个链表非空的判断比较好理解，然后我们看下removeEldestEntry这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认倩况下返回false的，那什么时候返回true，只有在removeEldestEntry也返回true的时候才会去执行删除“最老”的元素的操作，这样才比较符合我们的逻辑。其实目前LRU策略少一个判断，就是什么时候去执行删除最近最少操作的数据，重新看下LRU的概念，当内存不足时进行删除，而这个内存对LinkedHashMap来说其实就是大小，所以我们只需要在初始化LinkedHashMap的时候重写这个方法并且做一个判断，如果当前大小已经大于LinkedHashMap的容量就返回true,从而就会删除最近最少的数据，码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, Bitmap&gt; hardCache = <span class="keyword">new</span> LinkedHashMap&lt;String, Bitmap&gt;(</span><br><span class="line">			<span class="number">10</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Entry&lt;String, Bitmap&gt; entry)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.size() &gt; CAPACITY) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>到这里LinkedHashMap的LRU策略就实现了。下面我们验证下前面所说的。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map=<span class="keyword">new</span> LinkedHashMap&lt;String,String&gt;(<span class="number">5</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>)&#123;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(java.util.Map.Entry&lt;String,String&gt; eldest)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.size()&gt;<span class="number">5</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">	map.put(<span class="string">"key"</span>+i,<span class="string">"value"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span>(String value:map.values())&#123;</span><br><span class="line">	System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">value4</span><br></pre></td></tr></table></figure>
<p>下面我们get下map中的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">	map.put(<span class="string">"key"</span>+i,<span class="string">"value"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line">map.get(<span class="string">"key"</span>+<span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span>(String value:map.values())&#123;</span><br><span class="line">	System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value4</span><br><span class="line">value3</span><br></pre></td></tr></table></figure>
<p>结果和我们上面讲的是一致的。接下来改下代码再测试下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">	map.put(<span class="string">"key"</span>+i,<span class="string">"value"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line">map.get(<span class="string">"key"</span>+<span class="number">3</span>);</span><br><span class="line">map.put(<span class="string">"key5"</span>,<span class="string">"value new add"</span>);</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span>(String value:map.values())&#123;</span><br><span class="line">	System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是向已经满了的LinkedHashMap中继续添加一个元素，根据前所讲，应该会删除第一个元素，即为key0元素被删除，下面看下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value4</span><br><span class="line">value3</span><br><span class="line">value new add</span><br></pre></td></tr></table></figure>
<p>结果与我们前面所讲的一致。写到这里大家应该对linkedhashmap实现LRU有了一个全面的了解。利用这个机制在缓存图片的时候大大的优化内存使用率，使内存中保留的数据是经常使用的图片。</p>
]]></content>
      <categories>
        <category>安卓笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Dart基础语法</title>
    <url>/2019/11/26/Dart%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="dart语法基础">Dart语法基础</h2>
<p>本文内容主要是对Dart的语法基础进行总结，首先推荐一个线上调试Dart的地址<a href="https://repl.it/languages/dart" target="_blank" rel="noopener">repl.it</a>，下面开始对Dart语法进行介绍。</p>
<h3 id="初体验">初体验</h3>
<p>试着写一个hello world，你会发现Dart和Java还有Javascript都有些相似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printInteger(int a) &#123;</span><br><span class="line">  print(&apos;Hello world, this is $a.&apos;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  var number = 2019; </span><br><span class="line">  printInteger(number); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dart的变量与类型">Dart的变量与类型</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var 声明一个变量，表示类型由编译器推断决定</span><br><span class="line"></span><br><span class="line">Dart 是类型安全语言，all is object，甚至数字、布尔值、函数和 null 也都是继承自 Object 的对象</span><br><span class="line"></span><br><span class="line">基本类型：num bool String List map</span><br></pre></td></tr></table></figure>
<h4 id="数值类型">数值类型</h4>
<p>Dart 的数值类型 num ，有两种子类 int 和 double 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int x = 1;</span><br><span class="line">int hex = 0xEEADBEEF;</span><br><span class="line">double y = 1.1;</span><br><span class="line">double exponents = 1.13e5;</span><br><span class="line">int roundY = y.round();</span><br></pre></td></tr></table></figure>
<h4 id="布尔值">布尔值</h4>
<p>在 Dart 里，只有两个对象具有 bool 类型：true 和 false，它们都是编译时常量。</p>
<p>Dart 是类型安全的，因此我们不能使用 if(nonbooleanValue) 或 assert(nonbooleanValue) 之类的在 JavaScript 可以正常工作的代码，而应该显式地检查值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 检查是否为0.</span><br><span class="line">var number = 0;</span><br><span class="line">assert(number == 0);</span><br><span class="line">// assert(number); 错误</span><br></pre></td></tr></table></figure>
<h4 id="string">string</h4>
<p>Dart 的 String 由 UTF-16 的字符串组成。和 JavaScript 一样，构造字符串字面量时既能使用单引号也能使用双引号，还能在字符串中嵌入变量或表达式：你可以使用 ${express} 把一个表达式的值放进字符串。而如果是一个标识符，你可以省略{}。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s = &apos;cat&apos;;</span><br><span class="line">var s1 = &apos;this is a uppercased string: $&#123;s.toUpperCase()&#125;&apos;;</span><br><span class="line"></span><br><span class="line">var s2 = &apos;Hello&apos; + &apos; &apos; + &apos;World!&apos; ;</span><br><span class="line">var s3 = &quot;&quot;&quot;This is amulti-line string.&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="list与map">List与map</h4>
<p>它们的声明和使用很简单，和 JavaScript 中的用法类似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr1 = [&quot;Tom&quot;, &quot;Andy&quot;, &quot;Jack&quot;];</span><br><span class="line">var arr2 = List.of([1,2,3]);</span><br><span class="line">arr2.add(499);</span><br><span class="line">arr2.forEach((v) =&gt; print(&apos;$&#123;v&#125;&apos;));</span><br><span class="line">  </span><br><span class="line">var map1 = &#123;&quot;name&quot;: &quot;Tom&quot;, &apos;sex&apos;: &apos;male&apos;&#125;; </span><br><span class="line">var map2 = new Map();</span><br><span class="line">map2[&apos;name&apos;] = &apos;Tom&apos;;</span><br><span class="line">map2[&apos;sex&apos;] = &apos;male&apos;;</span><br><span class="line">map2.forEach((k,v) =&gt; print(&apos;$&#123;k&#125;: $&#123;v&#125;&apos;));</span><br></pre></td></tr></table></figure>
<p>和 Java 语言类似，在初始化集合实例对象时，你可以为它的类型添加约束，也可以用于后续判断集合类型。</p>
<p>下面的这段代码，在增加了类型约束后，语义会更清晰</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr1 = &lt;String&gt;[&apos;Tom&apos;, &apos;Andy&apos;, &apos;Jack&apos;];</span><br><span class="line">var arr2 = new List&lt;int&gt;.of([1,2,3]);</span><br><span class="line">arr2.add(499);</span><br><span class="line">arr2.forEach((v) =&gt; print(&apos;$&#123;v&#125;&apos;));</span><br><span class="line">print(arr2 is List&lt;int&gt;); // true</span><br><span class="line"></span><br><span class="line">var map1 = &lt;String, String&gt;&#123;&apos;name&apos;: &apos;Tom&apos;,&apos;sex&apos;: &apos;male&apos;,&#125;;</span><br><span class="line">var map2 = new Map&lt;String, String&gt;();</span><br><span class="line">map2[&apos;name&apos;] = &apos;Tom&apos;;</span><br><span class="line">map2[&apos;sex&apos;] = &apos;male&apos;;</span><br><span class="line">map2.forEach((k,v) =&gt; print(&apos;$&#123;k&#125;: $&#123;v&#125;&apos;)); </span><br><span class="line">print(map2 is Map&lt;String, String&gt;); // true</span><br></pre></td></tr></table></figure>
<h4 id="常量定义">常量定义</h4>
<ul>
<li>const，表示变量在编译期间即能确定的值；</li>
<li>final 则不太一样，用它定义的变量可以在运行时确定值，而一旦确定后就不可再变。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final name = &apos;Andy&apos;;</span><br><span class="line">const count = 3;</span><br><span class="line"></span><br><span class="line">var x = 70;  </span><br><span class="line">var y = 30;</span><br><span class="line">final z = x / y;</span><br></pre></td></tr></table></figure>
<h3 id="函数">函数</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool isZero(int number) &#123; //判断整数是否为0</span><br><span class="line">  return number == 0; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printInfo(int number,Function check) &#123; //用check函数来判断整数是否为0</span><br><span class="line">  print(&quot;$number is Zero: $&#123;check(number)&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function f = isZero;</span><br><span class="line">int x = 10;</span><br><span class="line">int y = 0;</span><br><span class="line">printInfo(x,f);  // 输出 10 is Zero: false</span><br><span class="line">printInfo(y,f);  // 输出 0 is Zero: true</span><br></pre></td></tr></table></figure>
<p>还可以像 JavaScript 语言那样用箭头函数来简化这个函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool isZero(int number) =&gt; number == 0;</span><br><span class="line"></span><br><span class="line">void printInfo(int number,Function check) =&gt; print(&quot;$number is Zero: $&#123;check(number)&#125;&quot;);</span><br></pre></td></tr></table></figure>
<p>C++ 与 Java 提供函数的重载，即提供同名但参数不同的函数。</p>
<p>Dart 认为重载会导致混乱，因此从设计之初就不支持重载，而是提供了可选命名参数和可选参数。</p>
<p>具体方式是，在声明函数时：</p>
<ul>
<li>给参数增加{}，以 paramName: value 的方式指定调用参数，也就是可选命名参数；</li>
<li>给参数增加 []，则意味着这些参数是可以忽略的，也就是可选参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//要达到可选命名参数的用法，那就在定义函数的时候给参数加上 &#123;&#125;</span><br><span class="line">void enable1Flags(&#123;bool bold, bool hidden&#125;) =&gt; print(&quot;$bold , $hidden&quot;);</span><br><span class="line"></span><br><span class="line">//定义可选命名参数时增加默认值</span><br><span class="line">void enable2Flags(&#123;bool bold = true, bool hidden = false&#125;) =&gt; print(&quot;$bold ,$hidden&quot;);</span><br><span class="line"></span><br><span class="line">//可忽略的参数在函数定义时用[]符号指定</span><br><span class="line">void enable3Flags(bool bold, [bool hidden]) =&gt; print(&quot;$bold ,$hidden&quot;);</span><br><span class="line"></span><br><span class="line">//定义可忽略参数时增加默认值</span><br><span class="line">void enable4Flags(bool bold, [bool hidden = false]) =&gt; print(&quot;$bold ,$hidden&quot;);</span><br><span class="line"></span><br><span class="line">//可选命名参数函数调用</span><br><span class="line">enable1Flags(bold: true, hidden: false); //true, false</span><br><span class="line">enable1Flags(bold: true); //true, null</span><br><span class="line">enable2Flags(bold: false); //false, false</span><br><span class="line"></span><br><span class="line">//可忽略参数函数调用</span><br><span class="line">enable3Flags(true, false); //true, false</span><br><span class="line">enable3Flags(true,); //true, null</span><br><span class="line">enable4Flags(true); //true, false</span><br><span class="line">enable4Flags(true,true); // true, true</span><br></pre></td></tr></table></figure>
<h3 id="类">类</h3>
<p>Dart 是面向对象的语言，每个对象都是一个类的实例，都继承自顶层类型 Object。</p>
<p>Dart 中并没有 public、protected、private 这些关键字，我们只要在声明变量与方法时，在前面加上“<strong>”即可作为 private 方法使用。如果不加“</strong>”，则默认为 public。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  num x, y;</span><br><span class="line">  static num factor = 0;</span><br><span class="line">  //语法糖，等同于在函数体内：this.x = x;this.y = y;</span><br><span class="line">  Point(this.x,this.y);</span><br><span class="line">  void printInfo() =&gt; print(&apos;($x, $y)&apos;);</span><br><span class="line">  static void printZValue() =&gt; print(&apos;$factor&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Point(100,200); // new 关键字可以省略</span><br><span class="line">p.printInfo();  // 输出(100, 200);</span><br><span class="line">Point.factor = 10;</span><br><span class="line">Point.printZValue(); // 输出10</span><br></pre></td></tr></table></figure>
<p>与 C++ 类似，Dart 支持初始化列表。在构造函数的函数体真正执行之前，你还有机会给实例变量赋值，甚至重定向至另一个构造函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  num x, y, z;</span><br><span class="line">  Point(this.x, this.y) : z = 0; // 初始化变量z</span><br><span class="line">  Point.bottom(num x) : this(x, 0); // 重定向构造函数</span><br><span class="line">  void printInfo() =&gt; print(&apos;($x,$y,$z)&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Point.bottom(100);</span><br><span class="line">p.printInfo(); // 输出(100,0,0)</span><br></pre></td></tr></table></figure>
<h3 id="复用">复用</h3>
<p>复用的方式一般有两种：继承父类和接口实现。这两方方式的区别如下：</p>
<ul>
<li>继承父类意味着，子类由父类派生，会自动获取父类的成员变量和方法实现，子类可以根据需要覆写构造函数及父类方法；</li>
<li>接口实现则意味着，子类获取到的仅仅是接口的成员变量符号和方法符号，需要重新实现成员变量，以及方法的声明和初始化，否则编译器会报错。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  num x = 0, y = 0;</span><br><span class="line">  void printInfo() =&gt; print(&apos;($x,$y)&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Vector继承自Point</span><br><span class="line">class Vector extends Point&#123;</span><br><span class="line">  num z = 0;</span><br><span class="line">  @override</span><br><span class="line">  void printInfo() =&gt; print(&apos;($x,$y,$z)&apos;); //覆写了printInfo实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Coordinate是对Point的接口实现</span><br><span class="line">//Dart中，每个类都是接口。Coordinate必须实现Point的除构造函数之外的所有成员函数和成员变量</span><br><span class="line">class Coordinate implements Point &#123;</span><br><span class="line">  num x = 0, y = 0; //成员变量需要重新声明</span><br><span class="line">  void printInfo() =&gt; print(&apos;($x,$y)&apos;); //成员函数需要重新声明实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var xxx = Vector(); </span><br><span class="line">xxx</span><br><span class="line">  ..x = 1</span><br><span class="line">  ..y = 2</span><br><span class="line">  ..z = 3; //级联运算符，等同于xxx.x=1; xxx.y=2;xxx.z=3;</span><br><span class="line">xxx.printInfo(); //输出(1,2,3)</span><br><span class="line"></span><br><span class="line">var yyy = Coordinate();</span><br><span class="line">yyy</span><br><span class="line">  ..x = 1</span><br><span class="line">  ..y = 2; //级联运算符，等同于yyy.x=1; yyy.y=2;</span><br><span class="line">yyy.printInfo(); //输出(1,2)</span><br><span class="line">print (yyy is Point); //true</span><br><span class="line">print(yyy is Coordinate); //true</span><br></pre></td></tr></table></figure>
<p>可以看出，子类 Coordinate 采用接口实现的方式，仅仅是获取到了父类 Point 的一个“空壳子”，只能从语义层面当成接口 Point 来用，但并不能复用 Point 的原有实现。那么，我们是否能够找到方法去复用 Point 的对应方法实现呢？</p>
<h4 id="混入-mixin">混入（Mixin）</h4>
<p>Dart 的继承是单继承，如果上栗中 Coordinate 已经有了父类，又想要去复用 Point 的原有的实现，如何实现？</p>
<p>Dart提供了混入机制，只需要 with 关键字即可。</p>
<p>维基百科：在面向对象的语言中，mixins类是一个可以把自己的方法提供给其他类使用，但却不需要成为其他类的父类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CoordinateT with Point &#123;</span><br><span class="line">  CoordinateT() &#123;</span><br><span class="line">    x = 20;</span><br><span class="line">    y = 20;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var yyy = Coordinate();</span><br><span class="line">print (yyy is Point); //true</span><br><span class="line">print(yyy is Coordinate); //true</span><br><span class="line">yyy.printInfo()//(20,20)</span><br></pre></td></tr></table></figure>
<p>minxin不是多继承：</p>
<p>Mixins is not a way to get multiple inheritance in the classical sense. Mixins is a way to abstract and reuse a family of operations and state. It is similar to the reuse you get from extending a class, but it is compatible with single-inheritance because it is linear.</p>
<h4 id="抽象类">抽象类</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Animals &#123;</span><br><span class="line">  num age;</span><br><span class="line"></span><br><span class="line">  void eat() =&gt; print(&quot;eat&quot;);</span><br><span class="line">  void run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Human extends Animals&#123;</span><br><span class="line">  @override</span><br><span class="line">  void run() &#123;</span><br><span class="line">    // TODO: implement run</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象类不能被实例化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Animals animals= Animals(); //error</span><br></pre></td></tr></table></figure>
<p>总结自：极客时间《Flutter核心技术与实战》-陈航</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native 新架构-JSI</title>
    <url>/2024/01/30/ReactNative%E6%96%B0%E6%9E%B6%E6%9E%84-JSI/</url>
    <content><![CDATA[<p>本文主要介绍下RN新架构中的JSI</p>
<h1>简单对比</h1>
<h2 id="老框架">老框架</h2>
<p><img src="/2024/01/30/ReactNative新架构-JSI/old.png" alt></p>
<p>老框架问题：</p>
<ol>
<li>业务启动一次性初始化全部 NativeModule</li>
<li>所有的调用为异步操作（同步桥除外）</li>
<li>JS 和 原生端通过 JSON 进通信</li>
<li>桥通信由于排队、线程切换易引起阻塞</li>
</ol>
<h2 id="新框架">新框架</h2>
<p><img src="/2024/01/30/ReactNative新架构-JSI/new.png" alt></p>
<p>新框架的优势：</p>
<ol>
<li>JSI：增加引擎抽相层，实现引擎解耦便于切换引擎，支持 JS 持有 C++ HostObject 引用，实现 JS 和 Native 相互感知。</li>
<li>TurboModule：替换原有桥机制，实现 Native Module 按需加载。</li>
<li>Fabric：新 UI 框架，替换原有的 UIManager。</li>
<li>Code Gen：工具，用户实现Fabric 和 TurboModule 的 JSI 框架代码，同时加入 JS 静态代码检查功能。</li>
</ol>
<h1>JSI</h1>
<p>JSI 是新框架的基石，JSI 的引入带来两个比较直观的改变：</p>
<ol>
<li>基于 JSI 对引擎的隔离，我们可以方便的将 JSC 换成其他 JS 引擎，如 V8 或专为移动端设计的 Hermes。</li>
<li>使用 JSI，JavaScript 可以持有 C++ 侧对象的引用并调用其方法，做到 JS 与 Native 的互通，不再依赖消息序列化队列进行通信。</li>
</ol>
<p><img src="/2024/01/30/ReactNative新架构-JSI/JSI.png" alt></p>
<p>详细介绍：</p>
<ol>
<li>HostFunctionType（可被JS调用的C++方法）：HostFunctionType 向JS VM注入的函数类型，供JS调用。</li>
<li>HostObject （可被JS侧持有的C++对象）：向JS VM注入的Object类型，供JS调用。</li>
<li>HostFunctionType 和 HostObject 这两个是 JS &lt;-&gt; C++ 互通的基础。</li>
<li>JSI 定义了常见的数据类型(String/Array/Object等) 并提供了数据转化、类型判断等方法。</li>
<li>JSI 通过接口实现引擎解耦，比如 evaluateJavaScirpt() 用于执行 JS 代码、prepareJavaScript() 预编译js代码、evaluatePreparedJavaScript() 执行预编译的js代码、global() 获取全局变量。</li>
</ol>
]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native 渲染机制</title>
    <url>/2021/02/08/ReactNative%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>本文主要总结下 React Native 的渲染机制</p>
<h2 id="总体架构">总体架构</h2>
<h3 id="树">树</h3>
<ul>
<li>Fiber 树：React Native 维护和更新开发者创建的 Component 的状态，创建出表达 UI 的第一种数据结构——Fiber 树。（节点为定义在 ReactNativeRenderer-xxx.js 中的 FiberNode）</li>
<li>Shadow 树：通过 Fiber 算法高效地执行树的更新动作（diff 算法），输出的结果表现为原生侧的 Shadow 树数据结构。（节点定义 ReactShadowNode.java、布局算法 Yoga 节点 YogaNode.java）</li>
<li>UI 树：再经过一些最终调整后，创建出原生平台上的 UI 结构——Android View 或 iOS UIView 所构成的树结构，由原生平台的渲染机制来完成屏幕内容的渲染。（Android View / ViewGroup）</li>
</ul>
<h3 id="线程模型">线程模型</h3>
<p>React Native Android 的世界，语言至少有三种（JavaScript、Java、C++），虚拟机有两个（JavaScript 虚拟机、Java 虚拟机）。</p>
<p>线程：</p>
<ul>
<li>JavaScript 线程（mqt_js）：JavaScript 脚本运行的线程，在该线程维护处理 Fiber 树，运行节点更新算法。</li>
<li>Shadow 线程（mqt_native_modules）：JavaScript 调用原生代码的线程，在该线程维护处理 shadow 树。</li>
<li>Android UI 线程，Android 完成原生平台的 UI 渲染。</li>
</ul>
<h3 id="js-侧核心">JS 侧核心</h3>
<ul>
<li>JS Virtual Dom 树的数据数据结构：JavaScript 层通过维护 Fiber 树，计算出数据结构变化的副作用，生成结点更新指令（createView / updateView / setChildren 等）送往 Java 层，实体结构 shadow tree 在 Java 层 UIImplementation 中生成。</li>
<li>在 setState 等入口触发刷新：setState 改变节点的状态，触发了 Fiber 框架管理下的 diff 过程。</li>
</ul>
<h2 id="js-与-native-通信">JS 与 Native 通信</h2>
<h3 id="更新-ui-的逻辑路径">更新 UI 的逻辑路径</h3>
<p>JavaScript 的 ReactNativeRenderer-xxx.js（xxx = dev / prod / profiling）维护了 virtual DOM 树，并通过几种更新操作，同步消息给原生层，最终创建并维护原生 view hierarchy：JavaScript 调用最后都会到达 NativeModules.js 中，然后通过 BatchedBridge.enqueueNativeCall() 调出到达原生世界。</p>
<p>Java 中的第一个类是 UIManagerModule.java。它将各操作转发给最关键的 UIImplementation 类以建立 shadow tree。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UIManagerModule</span> <span class="keyword">extends</span> <span class="title">ReactContextBaseJavaModule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UIImplementation mUIImplementation;</span><br><span class="line">		...</span><br><span class="line">    <span class="meta">@ReactMethod</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createView</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@ReactMethod</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateView</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@ReactMethod</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manageChildren</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@ReactMethod</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    ···</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过若干个 createView / setChildren / updateView 等操作建立起整个 shadow tree，之后在 UIManagerModule#onBatchComplete() -&gt; UIImplementation#dispatchViewUpdates() 中发起布局计算。UIImplementation#mShadowNodeRegistry 是存储这棵 shadow tree 的具体数据结构，每个 shadow 节点有一个整数 tag，其内部的 mTagsToCSSNodes map 维护了从 tag 到每个 ReactShadowNode 结构的映射关系。</p>
<p><strong>NativeViewHierarchyOptimizer</strong>：其负责将 shadow tree 转译为真正的原生 view 树。shadow tree 和原生 view 树有何不同呢？后者去掉了前者结构之中多余的 “纯布局 view”（layout-only view，即只影响 layout 但自身不绘制任何东西的 view）。</p>
<p>总体过程：</p>
<ul>
<li>ShadowTree
<ul>
<li>1：创建 ShadowNode，并保存成数组</li>
<li>2：设置 ShadowNode 的父子关系，正式完成树形结构搭建</li>
<li>3：排版过程
<ul>
<li>第一步：calculate，从 root 开始，计算每个 ShadowNode 的大小，每个 ReactShadowNode 对象内部封装了一个对应的 YogaNode 对象，排版算法 Yoga 是用 C++ 实现（YGJNIVanilla.cpp -&gt; Yoga.cpp）的</li>
<li>第二步：递归设置每个节点的屏幕坐标（左上角 + 宽高）</li>
</ul>
</li>
</ul>
</li>
<li>NativeTree
<ul>
<li>1：创建原生的 View / ViewGroup</li>
<li>2：设置原生 View / ViewGroup 的父子关系</li>
<li>3：根据 ShadowNode 的屏幕坐标更新原生 View / ViewGroup 的 layout 信息（这里会做一次假的原生 View 的 measure 的过程，实际上并不是真的要去计算大小，只是保证 Android 平台上无 bug）</li>
</ul>
</li>
</ul>
<p>下面看下详细过程。</p>
<h4 id="创建-shadow-tree">创建 Shadow Tree</h4>
<p>Shadow Tree由Shadow Node构成，Shadow Node与Fiber Tree的叶子结点一一对应，它有两个作用：</p>
<ul>
<li>1：映射生成Native控件</li>
<li>2：计算Native控件的布局</li>
</ul>
<p>构建 Node 的时候有 2 类比较特殊的节点</p>
<ul>
<li>虚节点：虚节点在计算布局时会被忽略，并且也不会生成相应的Native控件。目前虚节点在RN中的应用场景仅有<text>组件，它被用来处理<text>的嵌套逻辑：最外层<text>会映射成的实节点，而内层<text>会映射成虚节点。</text></text></text></text></li>
<li>LayoutOnly节点：LayoutOnly节点为Android侧独有的逻辑。构建Shadow Tree的过程中，并不是每个Shadow Node都会生成对应的UIViewOperation。这其中有一个关键判断：isLayoutOnly：如果一个View只会影响到它的子View的位置，而它本身不需要绘制任何内容，就可以不用生成真实的Native View。这样做的好处是可以减少View Tree的层级，优化Native侧的渲染性能。</li>
</ul>
<p>isLayoutOnly的判断逻辑如下：</p>
<ul>
<li>1：组件类型为<view></view></li>
<li>2：组件的props中不包含collapsable或collapsable值为false</li>
<li>3：组件的props中只包含对布局有影响的props，如width、height、margin、padding等</li>
</ul>
<h4 id="shadow-tree-操作">Shadow Tree 操作</h4>
<p>UIManagerModule根据JS侧传递过来的UI操作指令进行Shadow Tree的构建。构建的过程会完成两部分的工作：</p>
<ul>
<li>1：创建Shadow Node，进而构建出Shadow Tree。</li>
<li>2：生成对应的UIViewOperation，加入到UIViewOperationQueue中，以供在UI线程进行真正的UI操作。</li>
</ul>
<h4 id="布局计算">布局计算</h4>
<p>RN中的布局为Flex布局，它由Yoga引擎来完成。在计算View的宽度和高度时，Shadow Node有两种实现方式：</p>
<ul>
<li>1：委托给YogaNode进行计算：这是默认方式，例如LayoutShadowNode。</li>
<li>2：自行计算：通过setMeasureFunction方法把计算逻辑告诉YogaNode，例如ReactTextShadowNode。</li>
</ul>
<h4 id="ui-操作">UI 操作</h4>
<p>UI操作这一部分比较简单。DispatchUIFrameCallback由Choreographer触发，它从UIViewOperationQueue中依次取出UIViewOperation，执行相应的逻辑。
JS侧构建完Fiber Tree后，会将UI指令通过MessageQueue传递到Native侧。Fiber Tree  → Shadow Tree → (UIViewOperationQueue) → View Tree。</p>
<h3 id="js-调用-java-代码">JS 调用 Java 代码</h3>
<p>关键类：</p>
<ul>
<li>JavaScript 侧：NativeModules</li>
<li>Java 侧：JavaModuleWrapper、JavaMethodWrapper</li>
</ul>
<p>标记 Native 标记方法应如何被调用：</p>
<ul>
<li>METHOD_TYPE_ASYNC：异步调用（在 mqt_native_modules 线程上）</li>
<li>METHOD_TYPE_PROMISE：异步调用，返回一个 promise</li>
<li>METHOD_TYPE_SYNC：同步调用（在 mqt_js 线程上）</li>
</ul>
<h3 id="从原生到-javascript-通信方向"><strong><strong>从原生到 JavaScript 通信方向</strong></strong></h3>
<p><strong>传递事件的逻辑路径</strong></p>
<p>ReactRootView 作为 React Native 世界的容器布局，重写了 onInterceptTouchEvent() 和 onTouchEvent() 方法，获得所有触摸事件。调用 dispatchJSTouchEvent() 将部分事件传向 JavaScript 世界，在 JavaScript 侧处理，但在原生侧有坐标转换等逻辑，原生侧也会处理一部分事件。</p>
<p>EventDispatcher 内实现了成批传递事件的机制（event staging），每帧一批，减少穿越语言边界的开销。通过在 Choreographer 上注册的 ScheduleDispatchFrameCallback 类型的监听者，在收到 doFrame() 回调时将一批事件送往 JavaScript。在 Java 层一路调用，由 EventDispatcher 上由主线程切换到 mqt_js 线程，调用到 ReactEventEmitter#receiveTouches()。</p>
<p>getEventEmitter() 方法内，会从 ReactContext#getJSModule(Class<t> jsInterface) 获取在 CatalystInstanceImpl#mJSModuleRegisry 上注册好的 JavaScript 接口对象（RCTEventEmitter 类型），真正到达 JavaScript。</t></p>
<p><strong><strong>Java 调用 JavaScript 代码的方式</strong></strong></p>
<p>JavaScriptModuleRegistry 类内的 mModuleInstances 只起缓存作用，JavaScriptModule 对象都是该类自己根据类型反射创建出来的，实际向 JavaScript 的调用是由 CatalystInstance#callFunction() 处理的。</p>
<p>最终调用到了 JNI 方法 jniCallJSFunction()。我们进入 C++ 代码。</p>
<p>executor 是由一个 JSExecutorFactory 的 createJSExecutor() 函数创建的 JSCExecutor。具体创建 executor 的代码路径如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CatalystInstanceImpl.<span class="function">cpp <span class="title">initializeBridge</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">       |</span></span><br><span class="line"><span class="function">Instance.cpp <span class="title">initializeBridge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">       |                    </span></span><br><span class="line"><span class="function">NativeToJsBridge.cpp 构造方法</span></span><br><span class="line"><span class="function">       ｜</span></span><br><span class="line"><span class="function">JSCExecutorFactory <span class="title">createJSExecutor</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>这里具体的过程就不追了。这也是把 JSC 换成 v8 或者 Hermes 引擎的地方。</p>
<h2 id="fiber-算法">Fiber 算法</h2>
<p>双缓冲，两棵树：current 与 workInProgress，通过结点的 alternate 变量互相连接。</p>
<ul>
<li>current - 当前树，反映当前的 UI 状态</li>
<li>workInProgress - 工作过程树，反映更新过程中即将要到达的状态</li>
</ul>
<h2 id="react-native-重构">React Native 重构</h2>
<h3 id="重构的主要内容"><strong><strong>重构的主要内容</strong></strong></h3>
<ul>
<li>JavaScript Interface（JSI）：提供 JavaScript 代码直接同步调用原生代码的能力；同时作为 JavaScript 引擎的抽象层，允许换用不同的 JavaScript 引擎</li>
<li>TurboModules：基于 JSI 的新 NativeModules</li>
<li>Fabric：新的 UI 架构</li>
<li>CodeGen：解放开发者，自动 JSI 接口代码生成</li>
<li>LeanCore：将与核心不相关的组件从 React Native 仓库剥离为单独的仓库，交由社区维护，React Native 只维护核心组件</li>
</ul>
<h3 id="fabric-ui-架构-新旧对比"><strong><strong>Fabric UI 架构——新旧对比</strong></strong></h3>
<ul>
<li>原来的 Shadow 树维护在 Java 层（UIImplementation.java），Fabric 中用 C++ 实现，实现了双端一份代码来维护</li>
<li>JavaScript 层的 FabricUIManager.js 通过 JSI，在 C++ 层的 UIManager.cpp 中维护 Shadow 节点（ShadowNode.cpp）</li>
<li>JavaScript -- (JSI) --&gt; C++ -- (JNI) --&gt; Java 的一系列树节点同步动作，不再异步，都是同线程（mqt_js）、同步的；直到最后更新 UI 时，才切换到 UI 线程执行</li>
</ul>
]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
</search>
